// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef PROTOBUF_server_2eproto__INCLUDED
#define PROTOBUF_server_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace Xenophobia {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_server_2eproto();
void protobuf_AssignDesc_server_2eproto();
void protobuf_ShutdownFile_server_2eproto();

class ActionRequest;
class ActionResult;
class Change;
class EndVoting;
class InvetoryChange;
class PlayerChange;
class PlayerInfo;
class RegisterAnswer;
class RegisterUpdate;
class ServerMessage;
class StartGame;
class TimeSwitch;
class Voting;

enum ServerMessageType {
  SMT_REGISTER_ANSWER = 0,
  SMT_REGISTER_UPDATE = 1,
  SMT_START_GAME = 2,
  SMT_TIME_SWITCH = 3,
  SMT_VOTING = 4,
  SMT_END_VOTING = 5,
  SMT_CHANGE = 6,
  SMT_INVENTORY_CHANGE = 7,
  SMT_PLAYER_CHANGE = 8,
  SMT_ACTION_REQUEST = 9,
  SMT_ACTION_RESULT = 10,
  ServerMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServerMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServerMessageType_IsValid(int value);
const ServerMessageType ServerMessageType_MIN = SMT_REGISTER_ANSWER;
const ServerMessageType ServerMessageType_MAX = SMT_ACTION_RESULT;
const int ServerMessageType_ARRAYSIZE = ServerMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerMessageType_descriptor();
inline const ::std::string& ServerMessageType_Name(ServerMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerMessageType_descriptor(), value);
}
inline bool ServerMessageType_Parse(
    const ::std::string& name, ServerMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerMessageType>(
    ServerMessageType_descriptor(), name, value);
}
enum RegisterStatusType {
  NAME_CORRECT = 0,
  NAME_INCORRECT = 1,
  ROLE_CORRECT = 2,
  ROLE_INCORRECT = 3,
  RegisterStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RegisterStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RegisterStatusType_IsValid(int value);
const RegisterStatusType RegisterStatusType_MIN = NAME_CORRECT;
const RegisterStatusType RegisterStatusType_MAX = ROLE_INCORRECT;
const int RegisterStatusType_ARRAYSIZE = RegisterStatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterStatusType_descriptor();
inline const ::std::string& RegisterStatusType_Name(RegisterStatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterStatusType_descriptor(), value);
}
inline bool RegisterStatusType_Parse(
    const ::std::string& name, RegisterStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterStatusType>(
    RegisterStatusType_descriptor(), name, value);
}
enum TimeType {
  NIGHT_TIME = 0,
  DAY_TIME = 1,
  TimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TimeType_IsValid(int value);
const TimeType TimeType_MIN = NIGHT_TIME;
const TimeType TimeType_MAX = DAY_TIME;
const int TimeType_ARRAYSIZE = TimeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeType_descriptor();
inline const ::std::string& TimeType_Name(TimeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeType_descriptor(), value);
}
inline bool TimeType_Parse(
    const ::std::string& name, TimeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeType>(
    TimeType_descriptor(), name, value);
}
enum InvetoryChangeType {
  ADD_ITEM = 0,
  CHARGE_ITEM = 1,
  DEL_ITEM = 2,
  RECHARGE_ITEM = 3,
  InvetoryChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InvetoryChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InvetoryChangeType_IsValid(int value);
const InvetoryChangeType InvetoryChangeType_MIN = ADD_ITEM;
const InvetoryChangeType InvetoryChangeType_MAX = RECHARGE_ITEM;
const int InvetoryChangeType_ARRAYSIZE = InvetoryChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvetoryChangeType_descriptor();
inline const ::std::string& InvetoryChangeType_Name(InvetoryChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvetoryChangeType_descriptor(), value);
}
inline bool InvetoryChangeType_Parse(
    const ::std::string& name, InvetoryChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvetoryChangeType>(
    InvetoryChangeType_descriptor(), name, value);
}
enum PlayerChangeType {
  HP_CHANGE = 0,
  ALIEN = 1,
  STATUS_CHANGE = 2,
  PlayerChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PlayerChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PlayerChangeType_IsValid(int value);
const PlayerChangeType PlayerChangeType_MIN = HP_CHANGE;
const PlayerChangeType PlayerChangeType_MAX = STATUS_CHANGE;
const int PlayerChangeType_ARRAYSIZE = PlayerChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerChangeType_descriptor();
inline const ::std::string& PlayerChangeType_Name(PlayerChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerChangeType_descriptor(), value);
}
inline bool PlayerChangeType_Parse(
    const ::std::string& name, PlayerChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerChangeType>(
    PlayerChangeType_descriptor(), name, value);
}
enum RequestType {
  HARD_RESOLVE = 0,
  NEED_ROTATION = 1,
  RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = HARD_RESOLVE;
const RequestType RequestType_MAX = NEED_ROTATION;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum ResultType {
  USED_ITEM = 0,
  USE_ACTION = 1,
  ResultType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResultType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResultType_IsValid(int value);
const ResultType ResultType_MIN = USED_ITEM;
const ResultType ResultType_MAX = USE_ACTION;
const int ResultType_ARRAYSIZE = ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResultType_descriptor();
inline const ::std::string& ResultType_Name(ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResultType_descriptor(), value);
}
inline bool ResultType_Parse(
    const ::std::string& name, ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResultType>(
    ResultType_descriptor(), name, value);
}
// ===================================================================

class RegisterAnswer : public ::google::protobuf::Message {
 public:
  RegisterAnswer();
  virtual ~RegisterAnswer();

  RegisterAnswer(const RegisterAnswer& from);

  inline RegisterAnswer& operator=(const RegisterAnswer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAnswer& default_instance();

  void Swap(RegisterAnswer* other);

  // implements Message ----------------------------------------------

  inline RegisterAnswer* New() const { return New(NULL); }

  RegisterAnswer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterAnswer& from);
  void MergeFrom(const RegisterAnswer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterAnswer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.RegisterStatusType status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::Xenophobia::RegisterStatusType status() const;
  void set_status(::Xenophobia::RegisterStatusType value);

  // @@protoc_insertion_point(class_scope:Xenophobia.RegisterAnswer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static RegisterAnswer* default_instance_;
};
// -------------------------------------------------------------------

class RegisterUpdate : public ::google::protobuf::Message {
 public:
  RegisterUpdate();
  virtual ~RegisterUpdate();

  RegisterUpdate(const RegisterUpdate& from);

  inline RegisterUpdate& operator=(const RegisterUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterUpdate& default_instance();

  void Swap(RegisterUpdate* other);

  // implements Message ----------------------------------------------

  inline RegisterUpdate* New() const { return New(NULL); }

  RegisterUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterUpdate& from);
  void MergeFrom(const RegisterUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .types.Role> players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::types::Role >&
      players() const;
  ::google::protobuf::Map< ::std::string, ::types::Role >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:Xenophobia.RegisterUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::types::Role,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 >
      RegisterUpdate_PlayersEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::types::Role,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 > players_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static RegisterUpdate* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const { return New(NULL); }

  PlayerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .types.PlayerStatus status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::types::PlayerStatus status() const;
  void set_status(::types::PlayerStatus value);

  // optional bool online = 3;
  void clear_online();
  static const int kOnlineFieldNumber = 3;
  bool online() const;
  void set_online(bool value);

  // optional bool onduty = 4;
  void clear_onduty();
  static const int kOndutyFieldNumber = 4;
  bool onduty() const;
  void set_onduty(bool value);

  // optional int32 avatar = 5;
  void clear_avatar();
  static const int kAvatarFieldNumber = 5;
  ::google::protobuf::int32 avatar() const;
  void set_avatar(::google::protobuf::int32 value);

  // repeated .types.Role roles = 6;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 6;
  ::types::Role roles(int index) const;
  void set_roles(int index, ::types::Role value);
  void add_roles(::types::Role value);
  const ::google::protobuf::RepeatedField<int>& roles() const;
  ::google::protobuf::RepeatedField<int>* mutable_roles();

  // @@protoc_insertion_point(class_scope:Xenophobia.PlayerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int status_;
  bool online_;
  bool onduty_;
  ::google::protobuf::RepeatedField<int> roles_;
  mutable int _roles_cached_byte_size_;
  ::google::protobuf::int32 avatar_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class StartGame : public ::google::protobuf::Message {
 public:
  StartGame();
  virtual ~StartGame();

  StartGame(const StartGame& from);

  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartGame& default_instance();

  void Swap(StartGame* other);

  // implements Message ----------------------------------------------

  inline StartGame* New() const { return New(NULL); }

  StartGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartGame& from);
  void MergeFrom(const StartGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Xenophobia.PlayerInfo players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::Xenophobia::PlayerInfo& players(int index) const;
  ::Xenophobia::PlayerInfo* mutable_players(int index);
  ::Xenophobia::PlayerInfo* add_players();
  ::google::protobuf::RepeatedPtrField< ::Xenophobia::PlayerInfo >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::Xenophobia::PlayerInfo >&
      players() const;

  // @@protoc_insertion_point(class_scope:Xenophobia.StartGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Xenophobia::PlayerInfo > players_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static StartGame* default_instance_;
};
// -------------------------------------------------------------------

class TimeSwitch : public ::google::protobuf::Message {
 public:
  TimeSwitch();
  virtual ~TimeSwitch();

  TimeSwitch(const TimeSwitch& from);

  inline TimeSwitch& operator=(const TimeSwitch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSwitch& default_instance();

  void Swap(TimeSwitch* other);

  // implements Message ----------------------------------------------

  inline TimeSwitch* New() const { return New(NULL); }

  TimeSwitch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeSwitch& from);
  void MergeFrom(const TimeSwitch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeSwitch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.TimeType time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::Xenophobia::TimeType time() const;
  void set_time(::Xenophobia::TimeType value);

  // optional int32 day_number = 2;
  void clear_day_number();
  static const int kDayNumberFieldNumber = 2;
  ::google::protobuf::int32 day_number() const;
  void set_day_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.TimeSwitch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int time_;
  ::google::protobuf::int32 day_number_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static TimeSwitch* default_instance_;
};
// -------------------------------------------------------------------

class Voting : public ::google::protobuf::Message {
 public:
  Voting();
  virtual ~Voting();

  Voting(const Voting& from);

  inline Voting& operator=(const Voting& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Voting& default_instance();

  void Swap(Voting* other);

  // implements Message ----------------------------------------------

  inline Voting* New() const { return New(NULL); }

  Voting* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Voting& from);
  void MergeFrom(const Voting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Voting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.VotingType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::types::VotingType type() const;
  void set_type(::types::VotingType value);

  // repeated .types.ITarget targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  const ::types::ITarget& targets(int index) const;
  ::types::ITarget* mutable_targets(int index);
  ::types::ITarget* add_targets();
  ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
      mutable_targets();
  const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:Xenophobia.Voting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::types::ITarget > targets_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static Voting* default_instance_;
};
// -------------------------------------------------------------------

class EndVoting : public ::google::protobuf::Message {
 public:
  EndVoting();
  virtual ~EndVoting();

  EndVoting(const EndVoting& from);

  inline EndVoting& operator=(const EndVoting& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndVoting& default_instance();

  void Swap(EndVoting* other);

  // implements Message ----------------------------------------------

  inline EndVoting* New() const { return New(NULL); }

  EndVoting* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndVoting& from);
  void MergeFrom(const EndVoting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndVoting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.VotingType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::types::VotingType type() const;
  void set_type(::types::VotingType value);

  // optional .types.ITarget target = 2;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  const ::types::ITarget& target() const;
  ::types::ITarget* mutable_target();
  ::types::ITarget* release_target();
  void set_allocated_target(::types::ITarget* target);

  // optional string result = 3;
  void clear_result();
  static const int kResultFieldNumber = 3;
  const ::std::string& result() const;
  void set_result(const ::std::string& value);
  void set_result(const char* value);
  void set_result(const char* value, size_t size);
  ::std::string* mutable_result();
  ::std::string* release_result();
  void set_allocated_result(::std::string* result);

  // @@protoc_insertion_point(class_scope:Xenophobia.EndVoting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::types::ITarget* target_;
  ::google::protobuf::internal::ArenaStringPtr result_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static EndVoting* default_instance_;
};
// -------------------------------------------------------------------

class Change : public ::google::protobuf::Message {
 public:
  Change();
  virtual ~Change();

  Change(const Change& from);

  inline Change& operator=(const Change& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Change& default_instance();

  void Swap(Change* other);

  // implements Message ----------------------------------------------

  inline Change* New() const { return New(NULL); }

  Change* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Change& from);
  void MergeFrom(const Change& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Change* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.Event event = 1;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 1;
  const ::types::Event& event() const;
  ::types::Event* mutable_event();
  ::types::Event* release_event();
  void set_allocated_event(::types::Event* event);

  // @@protoc_insertion_point(class_scope:Xenophobia.Change)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::types::Event* event_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static Change* default_instance_;
};
// -------------------------------------------------------------------

class InvetoryChange : public ::google::protobuf::Message {
 public:
  InvetoryChange();
  virtual ~InvetoryChange();

  InvetoryChange(const InvetoryChange& from);

  inline InvetoryChange& operator=(const InvetoryChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvetoryChange& default_instance();

  void Swap(InvetoryChange* other);

  // implements Message ----------------------------------------------

  inline InvetoryChange* New() const { return New(NULL); }

  InvetoryChange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvetoryChange& from);
  void MergeFrom(const InvetoryChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvetoryChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.InvetoryChangeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::InvetoryChangeType type() const;
  void set_type(::Xenophobia::InvetoryChangeType value);

  // optional .types.Item item = 2;
  void clear_item();
  static const int kItemFieldNumber = 2;
  ::types::Item item() const;
  void set_item(::types::Item value);

  // optional int32 charge = 3;
  void clear_charge();
  static const int kChargeFieldNumber = 3;
  ::google::protobuf::int32 charge() const;
  void set_charge(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.InvetoryChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  int item_;
  ::google::protobuf::int32 charge_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static InvetoryChange* default_instance_;
};
// -------------------------------------------------------------------

class PlayerChange : public ::google::protobuf::Message {
 public:
  PlayerChange();
  virtual ~PlayerChange();

  PlayerChange(const PlayerChange& from);

  inline PlayerChange& operator=(const PlayerChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerChange& default_instance();

  void Swap(PlayerChange* other);

  // implements Message ----------------------------------------------

  inline PlayerChange* New() const { return New(NULL); }

  PlayerChange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerChange& from);
  void MergeFrom(const PlayerChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.PlayerChangeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::PlayerChangeType type() const;
  void set_type(::Xenophobia::PlayerChangeType value);

  // optional int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.PlayerChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::int32 value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static PlayerChange* default_instance_;
};
// -------------------------------------------------------------------

class ActionRequest : public ::google::protobuf::Message {
 public:
  ActionRequest();
  virtual ~ActionRequest();

  ActionRequest(const ActionRequest& from);

  inline ActionRequest& operator=(const ActionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRequest& default_instance();

  void Swap(ActionRequest* other);

  // implements Message ----------------------------------------------

  inline ActionRequest* New() const { return New(NULL); }

  ActionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRequest& from);
  void MergeFrom(const ActionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.RequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::RequestType type() const;
  void set_type(::Xenophobia::RequestType value);

  // repeated .types.ITarget targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  const ::types::ITarget& targets(int index) const;
  ::types::ITarget* mutable_targets(int index);
  ::types::ITarget* add_targets();
  ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
      mutable_targets();
  const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:Xenophobia.ActionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::types::ITarget > targets_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static ActionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ActionResult : public ::google::protobuf::Message {
 public:
  ActionResult();
  virtual ~ActionResult();

  ActionResult(const ActionResult& from);

  inline ActionResult& operator=(const ActionResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionResult& default_instance();

  void Swap(ActionResult* other);

  // implements Message ----------------------------------------------

  inline ActionResult* New() const { return New(NULL); }

  ActionResult* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionResult& from);
  void MergeFrom(const ActionResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.ResultType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::ResultType type() const;
  void set_type(::Xenophobia::ResultType value);

  // optional .types.Action action = 2;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::types::Action action() const;
  void set_action(::types::Action value);

  // @@protoc_insertion_point(class_scope:Xenophobia.ActionResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  int action_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static ActionResult* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  void Swap(ServerMessage* other);

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const { return New(NULL); }

  ServerMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.ServerMessageType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::ServerMessageType type() const;
  void set_type(::Xenophobia::ServerMessageType value);

  // optional .Xenophobia.RegisterAnswer register_answer = 2;
  bool has_register_answer() const;
  void clear_register_answer();
  static const int kRegisterAnswerFieldNumber = 2;
  const ::Xenophobia::RegisterAnswer& register_answer() const;
  ::Xenophobia::RegisterAnswer* mutable_register_answer();
  ::Xenophobia::RegisterAnswer* release_register_answer();
  void set_allocated_register_answer(::Xenophobia::RegisterAnswer* register_answer);

  // optional .Xenophobia.RegisterUpdate register_update = 3;
  bool has_register_update() const;
  void clear_register_update();
  static const int kRegisterUpdateFieldNumber = 3;
  const ::Xenophobia::RegisterUpdate& register_update() const;
  ::Xenophobia::RegisterUpdate* mutable_register_update();
  ::Xenophobia::RegisterUpdate* release_register_update();
  void set_allocated_register_update(::Xenophobia::RegisterUpdate* register_update);

  // optional .Xenophobia.StartGame start_game = 4;
  bool has_start_game() const;
  void clear_start_game();
  static const int kStartGameFieldNumber = 4;
  const ::Xenophobia::StartGame& start_game() const;
  ::Xenophobia::StartGame* mutable_start_game();
  ::Xenophobia::StartGame* release_start_game();
  void set_allocated_start_game(::Xenophobia::StartGame* start_game);

  // optional .Xenophobia.TimeSwitch time_switch = 5;
  bool has_time_switch() const;
  void clear_time_switch();
  static const int kTimeSwitchFieldNumber = 5;
  const ::Xenophobia::TimeSwitch& time_switch() const;
  ::Xenophobia::TimeSwitch* mutable_time_switch();
  ::Xenophobia::TimeSwitch* release_time_switch();
  void set_allocated_time_switch(::Xenophobia::TimeSwitch* time_switch);

  // optional .Xenophobia.Voting voting = 6;
  bool has_voting() const;
  void clear_voting();
  static const int kVotingFieldNumber = 6;
  const ::Xenophobia::Voting& voting() const;
  ::Xenophobia::Voting* mutable_voting();
  ::Xenophobia::Voting* release_voting();
  void set_allocated_voting(::Xenophobia::Voting* voting);

  // optional .Xenophobia.EndVoting end_voting = 7;
  bool has_end_voting() const;
  void clear_end_voting();
  static const int kEndVotingFieldNumber = 7;
  const ::Xenophobia::EndVoting& end_voting() const;
  ::Xenophobia::EndVoting* mutable_end_voting();
  ::Xenophobia::EndVoting* release_end_voting();
  void set_allocated_end_voting(::Xenophobia::EndVoting* end_voting);

  // optional .Xenophobia.Change change = 8;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 8;
  const ::Xenophobia::Change& change() const;
  ::Xenophobia::Change* mutable_change();
  ::Xenophobia::Change* release_change();
  void set_allocated_change(::Xenophobia::Change* change);

  // optional .Xenophobia.InvetoryChange inventory_change = 9;
  bool has_inventory_change() const;
  void clear_inventory_change();
  static const int kInventoryChangeFieldNumber = 9;
  const ::Xenophobia::InvetoryChange& inventory_change() const;
  ::Xenophobia::InvetoryChange* mutable_inventory_change();
  ::Xenophobia::InvetoryChange* release_inventory_change();
  void set_allocated_inventory_change(::Xenophobia::InvetoryChange* inventory_change);

  // optional .Xenophobia.PlayerChange player_change = 10;
  bool has_player_change() const;
  void clear_player_change();
  static const int kPlayerChangeFieldNumber = 10;
  const ::Xenophobia::PlayerChange& player_change() const;
  ::Xenophobia::PlayerChange* mutable_player_change();
  ::Xenophobia::PlayerChange* release_player_change();
  void set_allocated_player_change(::Xenophobia::PlayerChange* player_change);

  // optional .Xenophobia.ActionRequest action_request = 11;
  bool has_action_request() const;
  void clear_action_request();
  static const int kActionRequestFieldNumber = 11;
  const ::Xenophobia::ActionRequest& action_request() const;
  ::Xenophobia::ActionRequest* mutable_action_request();
  ::Xenophobia::ActionRequest* release_action_request();
  void set_allocated_action_request(::Xenophobia::ActionRequest* action_request);

  // optional .Xenophobia.ActionResult action_result = 12;
  bool has_action_result() const;
  void clear_action_result();
  static const int kActionResultFieldNumber = 12;
  const ::Xenophobia::ActionResult& action_result() const;
  ::Xenophobia::ActionResult* mutable_action_result();
  ::Xenophobia::ActionResult* release_action_result();
  void set_allocated_action_result(::Xenophobia::ActionResult* action_result);

  // @@protoc_insertion_point(class_scope:Xenophobia.ServerMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Xenophobia::RegisterAnswer* register_answer_;
  ::Xenophobia::RegisterUpdate* register_update_;
  ::Xenophobia::StartGame* start_game_;
  ::Xenophobia::TimeSwitch* time_switch_;
  ::Xenophobia::Voting* voting_;
  ::Xenophobia::EndVoting* end_voting_;
  ::Xenophobia::Change* change_;
  ::Xenophobia::InvetoryChange* inventory_change_;
  ::Xenophobia::PlayerChange* player_change_;
  ::Xenophobia::ActionRequest* action_request_;
  ::Xenophobia::ActionResult* action_result_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterAnswer

// optional .Xenophobia.RegisterStatusType status = 1;
inline void RegisterAnswer::clear_status() {
  status_ = 0;
}
inline ::Xenophobia::RegisterStatusType RegisterAnswer::status() const {
  // @@protoc_insertion_point(field_get:Xenophobia.RegisterAnswer.status)
  return static_cast< ::Xenophobia::RegisterStatusType >(status_);
}
inline void RegisterAnswer::set_status(::Xenophobia::RegisterStatusType value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.RegisterAnswer.status)
}

// -------------------------------------------------------------------

// RegisterUpdate

// map<string, .types.Role> players = 1;
inline int RegisterUpdate::players_size() const {
  return players_.size();
}
inline void RegisterUpdate::clear_players() {
  players_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::types::Role >&
RegisterUpdate::players() const {
  // @@protoc_insertion_point(field_map:Xenophobia.RegisterUpdate.players)
  return players_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::types::Role >*
RegisterUpdate::mutable_players() {
  // @@protoc_insertion_point(field_mutable_map:Xenophobia.RegisterUpdate.players)
  return players_.MutableMap();
}

// -------------------------------------------------------------------

// PlayerInfo

// optional string name = 1;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Xenophobia.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Xenophobia.PlayerInfo.name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Xenophobia.PlayerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfo::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.PlayerInfo.name)
}

// optional .types.PlayerStatus status = 2;
inline void PlayerInfo::clear_status() {
  status_ = 0;
}
inline ::types::PlayerStatus PlayerInfo::status() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerInfo.status)
  return static_cast< ::types::PlayerStatus >(status_);
}
inline void PlayerInfo::set_status(::types::PlayerStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerInfo.status)
}

// optional bool online = 3;
inline void PlayerInfo::clear_online() {
  online_ = false;
}
inline bool PlayerInfo::online() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerInfo.online)
  return online_;
}
inline void PlayerInfo::set_online(bool value) {
  
  online_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerInfo.online)
}

// optional bool onduty = 4;
inline void PlayerInfo::clear_onduty() {
  onduty_ = false;
}
inline bool PlayerInfo::onduty() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerInfo.onduty)
  return onduty_;
}
inline void PlayerInfo::set_onduty(bool value) {
  
  onduty_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerInfo.onduty)
}

// optional int32 avatar = 5;
inline void PlayerInfo::clear_avatar() {
  avatar_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::avatar() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerInfo.avatar)
  return avatar_;
}
inline void PlayerInfo::set_avatar(::google::protobuf::int32 value) {
  
  avatar_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerInfo.avatar)
}

// repeated .types.Role roles = 6;
inline int PlayerInfo::roles_size() const {
  return roles_.size();
}
inline void PlayerInfo::clear_roles() {
  roles_.Clear();
}
inline ::types::Role PlayerInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerInfo.roles)
  return static_cast< ::types::Role >(roles_.Get(index));
}
inline void PlayerInfo::set_roles(int index, ::types::Role value) {
  roles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerInfo.roles)
}
inline void PlayerInfo::add_roles(::types::Role value) {
  roles_.Add(value);
  // @@protoc_insertion_point(field_add:Xenophobia.PlayerInfo.roles)
}
inline const ::google::protobuf::RepeatedField<int>&
PlayerInfo::roles() const {
  // @@protoc_insertion_point(field_list:Xenophobia.PlayerInfo.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedField<int>*
PlayerInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.PlayerInfo.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// StartGame

// repeated .Xenophobia.PlayerInfo players = 1;
inline int StartGame::players_size() const {
  return players_.size();
}
inline void StartGame::clear_players() {
  players_.Clear();
}
inline const ::Xenophobia::PlayerInfo& StartGame::players(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.StartGame.players)
  return players_.Get(index);
}
inline ::Xenophobia::PlayerInfo* StartGame::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.StartGame.players)
  return players_.Mutable(index);
}
inline ::Xenophobia::PlayerInfo* StartGame::add_players() {
  // @@protoc_insertion_point(field_add:Xenophobia.StartGame.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Xenophobia::PlayerInfo >*
StartGame::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.StartGame.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Xenophobia::PlayerInfo >&
StartGame::players() const {
  // @@protoc_insertion_point(field_list:Xenophobia.StartGame.players)
  return players_;
}

// -------------------------------------------------------------------

// TimeSwitch

// optional .Xenophobia.TimeType time = 1;
inline void TimeSwitch::clear_time() {
  time_ = 0;
}
inline ::Xenophobia::TimeType TimeSwitch::time() const {
  // @@protoc_insertion_point(field_get:Xenophobia.TimeSwitch.time)
  return static_cast< ::Xenophobia::TimeType >(time_);
}
inline void TimeSwitch::set_time(::Xenophobia::TimeType value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.TimeSwitch.time)
}

// optional int32 day_number = 2;
inline void TimeSwitch::clear_day_number() {
  day_number_ = 0;
}
inline ::google::protobuf::int32 TimeSwitch::day_number() const {
  // @@protoc_insertion_point(field_get:Xenophobia.TimeSwitch.day_number)
  return day_number_;
}
inline void TimeSwitch::set_day_number(::google::protobuf::int32 value) {
  
  day_number_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.TimeSwitch.day_number)
}

// -------------------------------------------------------------------

// Voting

// optional .types.VotingType type = 1;
inline void Voting::clear_type() {
  type_ = 0;
}
inline ::types::VotingType Voting::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.Voting.type)
  return static_cast< ::types::VotingType >(type_);
}
inline void Voting::set_type(::types::VotingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.Voting.type)
}

// repeated .types.ITarget targets = 2;
inline int Voting::targets_size() const {
  return targets_.size();
}
inline void Voting::clear_targets() {
  targets_.Clear();
}
inline const ::types::ITarget& Voting::targets(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.Voting.targets)
  return targets_.Get(index);
}
inline ::types::ITarget* Voting::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.Voting.targets)
  return targets_.Mutable(index);
}
inline ::types::ITarget* Voting::add_targets() {
  // @@protoc_insertion_point(field_add:Xenophobia.Voting.targets)
  return targets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
Voting::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.Voting.targets)
  return &targets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
Voting::targets() const {
  // @@protoc_insertion_point(field_list:Xenophobia.Voting.targets)
  return targets_;
}

// -------------------------------------------------------------------

// EndVoting

// optional .types.VotingType type = 1;
inline void EndVoting::clear_type() {
  type_ = 0;
}
inline ::types::VotingType EndVoting::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.EndVoting.type)
  return static_cast< ::types::VotingType >(type_);
}
inline void EndVoting::set_type(::types::VotingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.EndVoting.type)
}

// optional .types.ITarget target = 2;
inline bool EndVoting::has_target() const {
  return !_is_default_instance_ && target_ != NULL;
}
inline void EndVoting::clear_target() {
  if (GetArenaNoVirtual() == NULL && target_ != NULL) delete target_;
  target_ = NULL;
}
inline const ::types::ITarget& EndVoting::target() const {
  // @@protoc_insertion_point(field_get:Xenophobia.EndVoting.target)
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::types::ITarget* EndVoting::mutable_target() {
  
  if (target_ == NULL) {
    target_ = new ::types::ITarget;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.EndVoting.target)
  return target_;
}
inline ::types::ITarget* EndVoting::release_target() {
  
  ::types::ITarget* temp = target_;
  target_ = NULL;
  return temp;
}
inline void EndVoting::set_allocated_target(::types::ITarget* target) {
  delete target_;
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.EndVoting.target)
}

// optional string result = 3;
inline void EndVoting::clear_result() {
  result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EndVoting::result() const {
  // @@protoc_insertion_point(field_get:Xenophobia.EndVoting.result)
  return result_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndVoting::set_result(const ::std::string& value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Xenophobia.EndVoting.result)
}
inline void EndVoting::set_result(const char* value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Xenophobia.EndVoting.result)
}
inline void EndVoting::set_result(const char* value, size_t size) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Xenophobia.EndVoting.result)
}
inline ::std::string* EndVoting::mutable_result() {
  
  // @@protoc_insertion_point(field_mutable:Xenophobia.EndVoting.result)
  return result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EndVoting::release_result() {
  
  return result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndVoting::set_allocated_result(::std::string* result) {
  if (result != NULL) {
    
  } else {
    
  }
  result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.EndVoting.result)
}

// -------------------------------------------------------------------

// Change

// optional .types.Event event = 1;
inline bool Change::has_event() const {
  return !_is_default_instance_ && event_ != NULL;
}
inline void Change::clear_event() {
  if (GetArenaNoVirtual() == NULL && event_ != NULL) delete event_;
  event_ = NULL;
}
inline const ::types::Event& Change::event() const {
  // @@protoc_insertion_point(field_get:Xenophobia.Change.event)
  return event_ != NULL ? *event_ : *default_instance_->event_;
}
inline ::types::Event* Change::mutable_event() {
  
  if (event_ == NULL) {
    event_ = new ::types::Event;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.Change.event)
  return event_;
}
inline ::types::Event* Change::release_event() {
  
  ::types::Event* temp = event_;
  event_ = NULL;
  return temp;
}
inline void Change::set_allocated_event(::types::Event* event) {
  delete event_;
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.Change.event)
}

// -------------------------------------------------------------------

// InvetoryChange

// optional .Xenophobia.InvetoryChangeType type = 1;
inline void InvetoryChange::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::InvetoryChangeType InvetoryChange::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.InvetoryChange.type)
  return static_cast< ::Xenophobia::InvetoryChangeType >(type_);
}
inline void InvetoryChange::set_type(::Xenophobia::InvetoryChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.InvetoryChange.type)
}

// optional .types.Item item = 2;
inline void InvetoryChange::clear_item() {
  item_ = 0;
}
inline ::types::Item InvetoryChange::item() const {
  // @@protoc_insertion_point(field_get:Xenophobia.InvetoryChange.item)
  return static_cast< ::types::Item >(item_);
}
inline void InvetoryChange::set_item(::types::Item value) {
  
  item_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.InvetoryChange.item)
}

// optional int32 charge = 3;
inline void InvetoryChange::clear_charge() {
  charge_ = 0;
}
inline ::google::protobuf::int32 InvetoryChange::charge() const {
  // @@protoc_insertion_point(field_get:Xenophobia.InvetoryChange.charge)
  return charge_;
}
inline void InvetoryChange::set_charge(::google::protobuf::int32 value) {
  
  charge_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.InvetoryChange.charge)
}

// -------------------------------------------------------------------

// PlayerChange

// optional .Xenophobia.PlayerChangeType type = 1;
inline void PlayerChange::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::PlayerChangeType PlayerChange::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerChange.type)
  return static_cast< ::Xenophobia::PlayerChangeType >(type_);
}
inline void PlayerChange::set_type(::Xenophobia::PlayerChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerChange.type)
}

// optional int32 value = 2;
inline void PlayerChange::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 PlayerChange::value() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerChange.value)
  return value_;
}
inline void PlayerChange::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerChange.value)
}

// -------------------------------------------------------------------

// ActionRequest

// optional .Xenophobia.RequestType type = 1;
inline void ActionRequest::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::RequestType ActionRequest::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionRequest.type)
  return static_cast< ::Xenophobia::RequestType >(type_);
}
inline void ActionRequest::set_type(::Xenophobia::RequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ActionRequest.type)
}

// repeated .types.ITarget targets = 2;
inline int ActionRequest::targets_size() const {
  return targets_.size();
}
inline void ActionRequest::clear_targets() {
  targets_.Clear();
}
inline const ::types::ITarget& ActionRequest::targets(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionRequest.targets)
  return targets_.Get(index);
}
inline ::types::ITarget* ActionRequest::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.ActionRequest.targets)
  return targets_.Mutable(index);
}
inline ::types::ITarget* ActionRequest::add_targets() {
  // @@protoc_insertion_point(field_add:Xenophobia.ActionRequest.targets)
  return targets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
ActionRequest::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.ActionRequest.targets)
  return &targets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
ActionRequest::targets() const {
  // @@protoc_insertion_point(field_list:Xenophobia.ActionRequest.targets)
  return targets_;
}

// -------------------------------------------------------------------

// ActionResult

// optional .Xenophobia.ResultType type = 1;
inline void ActionResult::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::ResultType ActionResult::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionResult.type)
  return static_cast< ::Xenophobia::ResultType >(type_);
}
inline void ActionResult::set_type(::Xenophobia::ResultType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ActionResult.type)
}

// optional .types.Action action = 2;
inline void ActionResult::clear_action() {
  action_ = 0;
}
inline ::types::Action ActionResult::action() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionResult.action)
  return static_cast< ::types::Action >(action_);
}
inline void ActionResult::set_action(::types::Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ActionResult.action)
}

// -------------------------------------------------------------------

// ServerMessage

// optional .Xenophobia.ServerMessageType type = 1;
inline void ServerMessage::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::ServerMessageType ServerMessage::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.type)
  return static_cast< ::Xenophobia::ServerMessageType >(type_);
}
inline void ServerMessage::set_type(::Xenophobia::ServerMessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ServerMessage.type)
}

// optional .Xenophobia.RegisterAnswer register_answer = 2;
inline bool ServerMessage::has_register_answer() const {
  return !_is_default_instance_ && register_answer_ != NULL;
}
inline void ServerMessage::clear_register_answer() {
  if (GetArenaNoVirtual() == NULL && register_answer_ != NULL) delete register_answer_;
  register_answer_ = NULL;
}
inline const ::Xenophobia::RegisterAnswer& ServerMessage::register_answer() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.register_answer)
  return register_answer_ != NULL ? *register_answer_ : *default_instance_->register_answer_;
}
inline ::Xenophobia::RegisterAnswer* ServerMessage::mutable_register_answer() {
  
  if (register_answer_ == NULL) {
    register_answer_ = new ::Xenophobia::RegisterAnswer;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.register_answer)
  return register_answer_;
}
inline ::Xenophobia::RegisterAnswer* ServerMessage::release_register_answer() {
  
  ::Xenophobia::RegisterAnswer* temp = register_answer_;
  register_answer_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_register_answer(::Xenophobia::RegisterAnswer* register_answer) {
  delete register_answer_;
  register_answer_ = register_answer;
  if (register_answer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.register_answer)
}

// optional .Xenophobia.RegisterUpdate register_update = 3;
inline bool ServerMessage::has_register_update() const {
  return !_is_default_instance_ && register_update_ != NULL;
}
inline void ServerMessage::clear_register_update() {
  if (GetArenaNoVirtual() == NULL && register_update_ != NULL) delete register_update_;
  register_update_ = NULL;
}
inline const ::Xenophobia::RegisterUpdate& ServerMessage::register_update() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.register_update)
  return register_update_ != NULL ? *register_update_ : *default_instance_->register_update_;
}
inline ::Xenophobia::RegisterUpdate* ServerMessage::mutable_register_update() {
  
  if (register_update_ == NULL) {
    register_update_ = new ::Xenophobia::RegisterUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.register_update)
  return register_update_;
}
inline ::Xenophobia::RegisterUpdate* ServerMessage::release_register_update() {
  
  ::Xenophobia::RegisterUpdate* temp = register_update_;
  register_update_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_register_update(::Xenophobia::RegisterUpdate* register_update) {
  delete register_update_;
  register_update_ = register_update;
  if (register_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.register_update)
}

// optional .Xenophobia.StartGame start_game = 4;
inline bool ServerMessage::has_start_game() const {
  return !_is_default_instance_ && start_game_ != NULL;
}
inline void ServerMessage::clear_start_game() {
  if (GetArenaNoVirtual() == NULL && start_game_ != NULL) delete start_game_;
  start_game_ = NULL;
}
inline const ::Xenophobia::StartGame& ServerMessage::start_game() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.start_game)
  return start_game_ != NULL ? *start_game_ : *default_instance_->start_game_;
}
inline ::Xenophobia::StartGame* ServerMessage::mutable_start_game() {
  
  if (start_game_ == NULL) {
    start_game_ = new ::Xenophobia::StartGame;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.start_game)
  return start_game_;
}
inline ::Xenophobia::StartGame* ServerMessage::release_start_game() {
  
  ::Xenophobia::StartGame* temp = start_game_;
  start_game_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_start_game(::Xenophobia::StartGame* start_game) {
  delete start_game_;
  start_game_ = start_game;
  if (start_game) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.start_game)
}

// optional .Xenophobia.TimeSwitch time_switch = 5;
inline bool ServerMessage::has_time_switch() const {
  return !_is_default_instance_ && time_switch_ != NULL;
}
inline void ServerMessage::clear_time_switch() {
  if (GetArenaNoVirtual() == NULL && time_switch_ != NULL) delete time_switch_;
  time_switch_ = NULL;
}
inline const ::Xenophobia::TimeSwitch& ServerMessage::time_switch() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.time_switch)
  return time_switch_ != NULL ? *time_switch_ : *default_instance_->time_switch_;
}
inline ::Xenophobia::TimeSwitch* ServerMessage::mutable_time_switch() {
  
  if (time_switch_ == NULL) {
    time_switch_ = new ::Xenophobia::TimeSwitch;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.time_switch)
  return time_switch_;
}
inline ::Xenophobia::TimeSwitch* ServerMessage::release_time_switch() {
  
  ::Xenophobia::TimeSwitch* temp = time_switch_;
  time_switch_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_time_switch(::Xenophobia::TimeSwitch* time_switch) {
  delete time_switch_;
  time_switch_ = time_switch;
  if (time_switch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.time_switch)
}

// optional .Xenophobia.Voting voting = 6;
inline bool ServerMessage::has_voting() const {
  return !_is_default_instance_ && voting_ != NULL;
}
inline void ServerMessage::clear_voting() {
  if (GetArenaNoVirtual() == NULL && voting_ != NULL) delete voting_;
  voting_ = NULL;
}
inline const ::Xenophobia::Voting& ServerMessage::voting() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.voting)
  return voting_ != NULL ? *voting_ : *default_instance_->voting_;
}
inline ::Xenophobia::Voting* ServerMessage::mutable_voting() {
  
  if (voting_ == NULL) {
    voting_ = new ::Xenophobia::Voting;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.voting)
  return voting_;
}
inline ::Xenophobia::Voting* ServerMessage::release_voting() {
  
  ::Xenophobia::Voting* temp = voting_;
  voting_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_voting(::Xenophobia::Voting* voting) {
  delete voting_;
  voting_ = voting;
  if (voting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.voting)
}

// optional .Xenophobia.EndVoting end_voting = 7;
inline bool ServerMessage::has_end_voting() const {
  return !_is_default_instance_ && end_voting_ != NULL;
}
inline void ServerMessage::clear_end_voting() {
  if (GetArenaNoVirtual() == NULL && end_voting_ != NULL) delete end_voting_;
  end_voting_ = NULL;
}
inline const ::Xenophobia::EndVoting& ServerMessage::end_voting() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.end_voting)
  return end_voting_ != NULL ? *end_voting_ : *default_instance_->end_voting_;
}
inline ::Xenophobia::EndVoting* ServerMessage::mutable_end_voting() {
  
  if (end_voting_ == NULL) {
    end_voting_ = new ::Xenophobia::EndVoting;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.end_voting)
  return end_voting_;
}
inline ::Xenophobia::EndVoting* ServerMessage::release_end_voting() {
  
  ::Xenophobia::EndVoting* temp = end_voting_;
  end_voting_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_end_voting(::Xenophobia::EndVoting* end_voting) {
  delete end_voting_;
  end_voting_ = end_voting;
  if (end_voting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.end_voting)
}

// optional .Xenophobia.Change change = 8;
inline bool ServerMessage::has_change() const {
  return !_is_default_instance_ && change_ != NULL;
}
inline void ServerMessage::clear_change() {
  if (GetArenaNoVirtual() == NULL && change_ != NULL) delete change_;
  change_ = NULL;
}
inline const ::Xenophobia::Change& ServerMessage::change() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.change)
  return change_ != NULL ? *change_ : *default_instance_->change_;
}
inline ::Xenophobia::Change* ServerMessage::mutable_change() {
  
  if (change_ == NULL) {
    change_ = new ::Xenophobia::Change;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.change)
  return change_;
}
inline ::Xenophobia::Change* ServerMessage::release_change() {
  
  ::Xenophobia::Change* temp = change_;
  change_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_change(::Xenophobia::Change* change) {
  delete change_;
  change_ = change;
  if (change) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.change)
}

// optional .Xenophobia.InvetoryChange inventory_change = 9;
inline bool ServerMessage::has_inventory_change() const {
  return !_is_default_instance_ && inventory_change_ != NULL;
}
inline void ServerMessage::clear_inventory_change() {
  if (GetArenaNoVirtual() == NULL && inventory_change_ != NULL) delete inventory_change_;
  inventory_change_ = NULL;
}
inline const ::Xenophobia::InvetoryChange& ServerMessage::inventory_change() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.inventory_change)
  return inventory_change_ != NULL ? *inventory_change_ : *default_instance_->inventory_change_;
}
inline ::Xenophobia::InvetoryChange* ServerMessage::mutable_inventory_change() {
  
  if (inventory_change_ == NULL) {
    inventory_change_ = new ::Xenophobia::InvetoryChange;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.inventory_change)
  return inventory_change_;
}
inline ::Xenophobia::InvetoryChange* ServerMessage::release_inventory_change() {
  
  ::Xenophobia::InvetoryChange* temp = inventory_change_;
  inventory_change_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_inventory_change(::Xenophobia::InvetoryChange* inventory_change) {
  delete inventory_change_;
  inventory_change_ = inventory_change;
  if (inventory_change) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.inventory_change)
}

// optional .Xenophobia.PlayerChange player_change = 10;
inline bool ServerMessage::has_player_change() const {
  return !_is_default_instance_ && player_change_ != NULL;
}
inline void ServerMessage::clear_player_change() {
  if (GetArenaNoVirtual() == NULL && player_change_ != NULL) delete player_change_;
  player_change_ = NULL;
}
inline const ::Xenophobia::PlayerChange& ServerMessage::player_change() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.player_change)
  return player_change_ != NULL ? *player_change_ : *default_instance_->player_change_;
}
inline ::Xenophobia::PlayerChange* ServerMessage::mutable_player_change() {
  
  if (player_change_ == NULL) {
    player_change_ = new ::Xenophobia::PlayerChange;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.player_change)
  return player_change_;
}
inline ::Xenophobia::PlayerChange* ServerMessage::release_player_change() {
  
  ::Xenophobia::PlayerChange* temp = player_change_;
  player_change_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_player_change(::Xenophobia::PlayerChange* player_change) {
  delete player_change_;
  player_change_ = player_change;
  if (player_change) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.player_change)
}

// optional .Xenophobia.ActionRequest action_request = 11;
inline bool ServerMessage::has_action_request() const {
  return !_is_default_instance_ && action_request_ != NULL;
}
inline void ServerMessage::clear_action_request() {
  if (GetArenaNoVirtual() == NULL && action_request_ != NULL) delete action_request_;
  action_request_ = NULL;
}
inline const ::Xenophobia::ActionRequest& ServerMessage::action_request() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.action_request)
  return action_request_ != NULL ? *action_request_ : *default_instance_->action_request_;
}
inline ::Xenophobia::ActionRequest* ServerMessage::mutable_action_request() {
  
  if (action_request_ == NULL) {
    action_request_ = new ::Xenophobia::ActionRequest;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.action_request)
  return action_request_;
}
inline ::Xenophobia::ActionRequest* ServerMessage::release_action_request() {
  
  ::Xenophobia::ActionRequest* temp = action_request_;
  action_request_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_action_request(::Xenophobia::ActionRequest* action_request) {
  delete action_request_;
  action_request_ = action_request;
  if (action_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.action_request)
}

// optional .Xenophobia.ActionResult action_result = 12;
inline bool ServerMessage::has_action_result() const {
  return !_is_default_instance_ && action_result_ != NULL;
}
inline void ServerMessage::clear_action_result() {
  if (GetArenaNoVirtual() == NULL && action_result_ != NULL) delete action_result_;
  action_result_ = NULL;
}
inline const ::Xenophobia::ActionResult& ServerMessage::action_result() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.action_result)
  return action_result_ != NULL ? *action_result_ : *default_instance_->action_result_;
}
inline ::Xenophobia::ActionResult* ServerMessage::mutable_action_result() {
  
  if (action_result_ == NULL) {
    action_result_ = new ::Xenophobia::ActionResult;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.action_result)
  return action_result_;
}
inline ::Xenophobia::ActionResult* ServerMessage::release_action_result() {
  
  ::Xenophobia::ActionResult* temp = action_result_;
  action_result_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_action_result(::Xenophobia::ActionResult* action_result) {
  delete action_result_;
  action_result_ = action_result;
  if (action_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.action_result)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Xenophobia

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Xenophobia::ServerMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::ServerMessageType>() {
  return ::Xenophobia::ServerMessageType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::RegisterStatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::RegisterStatusType>() {
  return ::Xenophobia::RegisterStatusType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::TimeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::TimeType>() {
  return ::Xenophobia::TimeType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::InvetoryChangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::InvetoryChangeType>() {
  return ::Xenophobia::InvetoryChangeType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::PlayerChangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::PlayerChangeType>() {
  return ::Xenophobia::PlayerChangeType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::RequestType>() {
  return ::Xenophobia::RequestType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::ResultType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::ResultType>() {
  return ::Xenophobia::ResultType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_server_2eproto__INCLUDED
