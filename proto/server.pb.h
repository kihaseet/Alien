// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef PROTOBUF_server_2eproto__INCLUDED
#define PROTOBUF_server_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace Xenophobia {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_server_2eproto();
void protobuf_AssignDesc_server_2eproto();
void protobuf_ShutdownFile_server_2eproto();

class ActionRequest;
class ActionResult;
class Change;
class EndVoting;
class InvetoryChange;
class PlayerChange;
class RegisterAnswer;
class RegisterUpdate;
class ServerMessage;
class StartGame;
class StartGame_PlayerInfo;
class TimeSwitch;
class Voting;

enum RegisterAnswer_StatusType {
  RegisterAnswer_StatusType_NAME_CORRECT = 0,
  RegisterAnswer_StatusType_NAME_INCORRECT = 1,
  RegisterAnswer_StatusType_ROLE_CORRECT = 2,
  RegisterAnswer_StatusType_ROLE_INCORRECT = 3,
  RegisterAnswer_StatusType_RegisterAnswer_StatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RegisterAnswer_StatusType_RegisterAnswer_StatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RegisterAnswer_StatusType_IsValid(int value);
const RegisterAnswer_StatusType RegisterAnswer_StatusType_StatusType_MIN = RegisterAnswer_StatusType_NAME_CORRECT;
const RegisterAnswer_StatusType RegisterAnswer_StatusType_StatusType_MAX = RegisterAnswer_StatusType_ROLE_INCORRECT;
const int RegisterAnswer_StatusType_StatusType_ARRAYSIZE = RegisterAnswer_StatusType_StatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterAnswer_StatusType_descriptor();
inline const ::std::string& RegisterAnswer_StatusType_Name(RegisterAnswer_StatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterAnswer_StatusType_descriptor(), value);
}
inline bool RegisterAnswer_StatusType_Parse(
    const ::std::string& name, RegisterAnswer_StatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterAnswer_StatusType>(
    RegisterAnswer_StatusType_descriptor(), name, value);
}
enum TimeSwitch_TimeType {
  TimeSwitch_TimeType_NIGHT_TIME = 0,
  TimeSwitch_TimeType_DAY_TIME = 1,
  TimeSwitch_TimeType_TimeSwitch_TimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TimeSwitch_TimeType_TimeSwitch_TimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TimeSwitch_TimeType_IsValid(int value);
const TimeSwitch_TimeType TimeSwitch_TimeType_TimeType_MIN = TimeSwitch_TimeType_NIGHT_TIME;
const TimeSwitch_TimeType TimeSwitch_TimeType_TimeType_MAX = TimeSwitch_TimeType_DAY_TIME;
const int TimeSwitch_TimeType_TimeType_ARRAYSIZE = TimeSwitch_TimeType_TimeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeSwitch_TimeType_descriptor();
inline const ::std::string& TimeSwitch_TimeType_Name(TimeSwitch_TimeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeSwitch_TimeType_descriptor(), value);
}
inline bool TimeSwitch_TimeType_Parse(
    const ::std::string& name, TimeSwitch_TimeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeSwitch_TimeType>(
    TimeSwitch_TimeType_descriptor(), name, value);
}
enum InvetoryChange_ChangeType {
  InvetoryChange_ChangeType_ADD_ITEM = 0,
  InvetoryChange_ChangeType_CHARGE_ITEM = 1,
  InvetoryChange_ChangeType_DEL_ITEM = 2,
  InvetoryChange_ChangeType_InvetoryChange_ChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InvetoryChange_ChangeType_InvetoryChange_ChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InvetoryChange_ChangeType_IsValid(int value);
const InvetoryChange_ChangeType InvetoryChange_ChangeType_ChangeType_MIN = InvetoryChange_ChangeType_ADD_ITEM;
const InvetoryChange_ChangeType InvetoryChange_ChangeType_ChangeType_MAX = InvetoryChange_ChangeType_DEL_ITEM;
const int InvetoryChange_ChangeType_ChangeType_ARRAYSIZE = InvetoryChange_ChangeType_ChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvetoryChange_ChangeType_descriptor();
inline const ::std::string& InvetoryChange_ChangeType_Name(InvetoryChange_ChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvetoryChange_ChangeType_descriptor(), value);
}
inline bool InvetoryChange_ChangeType_Parse(
    const ::std::string& name, InvetoryChange_ChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvetoryChange_ChangeType>(
    InvetoryChange_ChangeType_descriptor(), name, value);
}
enum PlayerChange_ChangeType {
  PlayerChange_ChangeType_HP_CHANGE = 0,
  PlayerChange_ChangeType_ALIEN = 1,
  PlayerChange_ChangeType_STATUS_CHANGE = 2,
  PlayerChange_ChangeType_PlayerChange_ChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PlayerChange_ChangeType_PlayerChange_ChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PlayerChange_ChangeType_IsValid(int value);
const PlayerChange_ChangeType PlayerChange_ChangeType_ChangeType_MIN = PlayerChange_ChangeType_HP_CHANGE;
const PlayerChange_ChangeType PlayerChange_ChangeType_ChangeType_MAX = PlayerChange_ChangeType_STATUS_CHANGE;
const int PlayerChange_ChangeType_ChangeType_ARRAYSIZE = PlayerChange_ChangeType_ChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerChange_ChangeType_descriptor();
inline const ::std::string& PlayerChange_ChangeType_Name(PlayerChange_ChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerChange_ChangeType_descriptor(), value);
}
inline bool PlayerChange_ChangeType_Parse(
    const ::std::string& name, PlayerChange_ChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerChange_ChangeType>(
    PlayerChange_ChangeType_descriptor(), name, value);
}
enum ActionRequest_RequestType {
  ActionRequest_RequestType_HARD_RESOLVE = 0,
  ActionRequest_RequestType_NEED_ROTATION = 1,
  ActionRequest_RequestType_ActionRequest_RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ActionRequest_RequestType_ActionRequest_RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ActionRequest_RequestType_IsValid(int value);
const ActionRequest_RequestType ActionRequest_RequestType_RequestType_MIN = ActionRequest_RequestType_HARD_RESOLVE;
const ActionRequest_RequestType ActionRequest_RequestType_RequestType_MAX = ActionRequest_RequestType_NEED_ROTATION;
const int ActionRequest_RequestType_RequestType_ARRAYSIZE = ActionRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionRequest_RequestType_descriptor();
inline const ::std::string& ActionRequest_RequestType_Name(ActionRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionRequest_RequestType_descriptor(), value);
}
inline bool ActionRequest_RequestType_Parse(
    const ::std::string& name, ActionRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionRequest_RequestType>(
    ActionRequest_RequestType_descriptor(), name, value);
}
enum ActionResult_ResultType {
  ActionResult_ResultType_USED_ITEM = 0,
  ActionResult_ResultType_USE_ACTION = 1,
  ActionResult_ResultType_ActionResult_ResultType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ActionResult_ResultType_ActionResult_ResultType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ActionResult_ResultType_IsValid(int value);
const ActionResult_ResultType ActionResult_ResultType_ResultType_MIN = ActionResult_ResultType_USED_ITEM;
const ActionResult_ResultType ActionResult_ResultType_ResultType_MAX = ActionResult_ResultType_USE_ACTION;
const int ActionResult_ResultType_ResultType_ARRAYSIZE = ActionResult_ResultType_ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionResult_ResultType_descriptor();
inline const ::std::string& ActionResult_ResultType_Name(ActionResult_ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionResult_ResultType_descriptor(), value);
}
inline bool ActionResult_ResultType_Parse(
    const ::std::string& name, ActionResult_ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionResult_ResultType>(
    ActionResult_ResultType_descriptor(), name, value);
}
enum ServerMessageType {
  SMT_REGISTER_ANSWER = 0,
  SMT_REGISTER_UPDATE = 1,
  SMT_START_GAME = 2,
  SMT_TIME_SWITCH = 3,
  SMT_VOTING = 4,
  SMT_END_VOTING = 5,
  SMT_CHANGE = 6,
  SMT_INVENTORY_CHANGE = 7,
  SMT_PLAYER_CHANGE = 8,
  SMT_ACTION_REQUEST = 9,
  SMT_ACTION_RESULT = 10,
  ServerMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ServerMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ServerMessageType_IsValid(int value);
const ServerMessageType ServerMessageType_MIN = SMT_REGISTER_ANSWER;
const ServerMessageType ServerMessageType_MAX = SMT_ACTION_RESULT;
const int ServerMessageType_ARRAYSIZE = ServerMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerMessageType_descriptor();
inline const ::std::string& ServerMessageType_Name(ServerMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerMessageType_descriptor(), value);
}
inline bool ServerMessageType_Parse(
    const ::std::string& name, ServerMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerMessageType>(
    ServerMessageType_descriptor(), name, value);
}
// ===================================================================

class RegisterAnswer : public ::google::protobuf::Message {
 public:
  RegisterAnswer();
  virtual ~RegisterAnswer();

  RegisterAnswer(const RegisterAnswer& from);

  inline RegisterAnswer& operator=(const RegisterAnswer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAnswer& default_instance();

  void Swap(RegisterAnswer* other);

  // implements Message ----------------------------------------------

  inline RegisterAnswer* New() const { return New(NULL); }

  RegisterAnswer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterAnswer& from);
  void MergeFrom(const RegisterAnswer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterAnswer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegisterAnswer_StatusType StatusType;
  static const StatusType NAME_CORRECT = RegisterAnswer_StatusType_NAME_CORRECT;
  static const StatusType NAME_INCORRECT = RegisterAnswer_StatusType_NAME_INCORRECT;
  static const StatusType ROLE_CORRECT = RegisterAnswer_StatusType_ROLE_CORRECT;
  static const StatusType ROLE_INCORRECT = RegisterAnswer_StatusType_ROLE_INCORRECT;
  static inline bool StatusType_IsValid(int value) {
    return RegisterAnswer_StatusType_IsValid(value);
  }
  static const StatusType StatusType_MIN =
    RegisterAnswer_StatusType_StatusType_MIN;
  static const StatusType StatusType_MAX =
    RegisterAnswer_StatusType_StatusType_MAX;
  static const int StatusType_ARRAYSIZE =
    RegisterAnswer_StatusType_StatusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusType_descriptor() {
    return RegisterAnswer_StatusType_descriptor();
  }
  static inline const ::std::string& StatusType_Name(StatusType value) {
    return RegisterAnswer_StatusType_Name(value);
  }
  static inline bool StatusType_Parse(const ::std::string& name,
      StatusType* value) {
    return RegisterAnswer_StatusType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Xenophobia.RegisterAnswer.StatusType status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::Xenophobia::RegisterAnswer_StatusType status() const;
  void set_status(::Xenophobia::RegisterAnswer_StatusType value);

  // @@protoc_insertion_point(class_scope:Xenophobia.RegisterAnswer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static RegisterAnswer* default_instance_;
};
// -------------------------------------------------------------------

class RegisterUpdate : public ::google::protobuf::Message {
 public:
  RegisterUpdate();
  virtual ~RegisterUpdate();

  RegisterUpdate(const RegisterUpdate& from);

  inline RegisterUpdate& operator=(const RegisterUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterUpdate& default_instance();

  void Swap(RegisterUpdate* other);

  // implements Message ----------------------------------------------

  inline RegisterUpdate* New() const { return New(NULL); }

  RegisterUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterUpdate& from);
  void MergeFrom(const RegisterUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .types.Role> players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::types::Role >&
      players() const;
  ::google::protobuf::Map< ::std::string, ::types::Role >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:Xenophobia.RegisterUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::types::Role,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 >
      RegisterUpdate_PlayersEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::types::Role,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 > players_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static RegisterUpdate* default_instance_;
};
// -------------------------------------------------------------------

class StartGame_PlayerInfo : public ::google::protobuf::Message {
 public:
  StartGame_PlayerInfo();
  virtual ~StartGame_PlayerInfo();

  StartGame_PlayerInfo(const StartGame_PlayerInfo& from);

  inline StartGame_PlayerInfo& operator=(const StartGame_PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartGame_PlayerInfo& default_instance();

  void Swap(StartGame_PlayerInfo* other);

  // implements Message ----------------------------------------------

  inline StartGame_PlayerInfo* New() const { return New(NULL); }

  StartGame_PlayerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartGame_PlayerInfo& from);
  void MergeFrom(const StartGame_PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartGame_PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.PlayerStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::types::PlayerStatus status() const;
  void set_status(::types::PlayerStatus value);

  // optional bool online = 2;
  void clear_online();
  static const int kOnlineFieldNumber = 2;
  bool online() const;
  void set_online(bool value);

  // optional bool onduty = 3;
  void clear_onduty();
  static const int kOndutyFieldNumber = 3;
  bool onduty() const;
  void set_onduty(bool value);

  // optional int32 avatar = 4;
  void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  ::google::protobuf::int32 avatar() const;
  void set_avatar(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.StartGame.PlayerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  bool online_;
  bool onduty_;
  ::google::protobuf::int32 avatar_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static StartGame_PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class StartGame : public ::google::protobuf::Message {
 public:
  StartGame();
  virtual ~StartGame();

  StartGame(const StartGame& from);

  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartGame& default_instance();

  void Swap(StartGame* other);

  // implements Message ----------------------------------------------

  inline StartGame* New() const { return New(NULL); }

  StartGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartGame& from);
  void MergeFrom(const StartGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StartGame_PlayerInfo PlayerInfo;

  // accessors -------------------------------------------------------

  // repeated .Xenophobia.StartGame.PlayerInfo players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::Xenophobia::StartGame_PlayerInfo& players(int index) const;
  ::Xenophobia::StartGame_PlayerInfo* mutable_players(int index);
  ::Xenophobia::StartGame_PlayerInfo* add_players();
  ::google::protobuf::RepeatedPtrField< ::Xenophobia::StartGame_PlayerInfo >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::Xenophobia::StartGame_PlayerInfo >&
      players() const;

  // @@protoc_insertion_point(class_scope:Xenophobia.StartGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Xenophobia::StartGame_PlayerInfo > players_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static StartGame* default_instance_;
};
// -------------------------------------------------------------------

class TimeSwitch : public ::google::protobuf::Message {
 public:
  TimeSwitch();
  virtual ~TimeSwitch();

  TimeSwitch(const TimeSwitch& from);

  inline TimeSwitch& operator=(const TimeSwitch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSwitch& default_instance();

  void Swap(TimeSwitch* other);

  // implements Message ----------------------------------------------

  inline TimeSwitch* New() const { return New(NULL); }

  TimeSwitch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeSwitch& from);
  void MergeFrom(const TimeSwitch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeSwitch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TimeSwitch_TimeType TimeType;
  static const TimeType NIGHT_TIME = TimeSwitch_TimeType_NIGHT_TIME;
  static const TimeType DAY_TIME = TimeSwitch_TimeType_DAY_TIME;
  static inline bool TimeType_IsValid(int value) {
    return TimeSwitch_TimeType_IsValid(value);
  }
  static const TimeType TimeType_MIN =
    TimeSwitch_TimeType_TimeType_MIN;
  static const TimeType TimeType_MAX =
    TimeSwitch_TimeType_TimeType_MAX;
  static const int TimeType_ARRAYSIZE =
    TimeSwitch_TimeType_TimeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeType_descriptor() {
    return TimeSwitch_TimeType_descriptor();
  }
  static inline const ::std::string& TimeType_Name(TimeType value) {
    return TimeSwitch_TimeType_Name(value);
  }
  static inline bool TimeType_Parse(const ::std::string& name,
      TimeType* value) {
    return TimeSwitch_TimeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Xenophobia.TimeSwitch.TimeType time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::Xenophobia::TimeSwitch_TimeType time() const;
  void set_time(::Xenophobia::TimeSwitch_TimeType value);

  // optional int32 day_number = 2;
  void clear_day_number();
  static const int kDayNumberFieldNumber = 2;
  ::google::protobuf::int32 day_number() const;
  void set_day_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.TimeSwitch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int time_;
  ::google::protobuf::int32 day_number_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static TimeSwitch* default_instance_;
};
// -------------------------------------------------------------------

class Voting : public ::google::protobuf::Message {
 public:
  Voting();
  virtual ~Voting();

  Voting(const Voting& from);

  inline Voting& operator=(const Voting& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Voting& default_instance();

  void Swap(Voting* other);

  // implements Message ----------------------------------------------

  inline Voting* New() const { return New(NULL); }

  Voting* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Voting& from);
  void MergeFrom(const Voting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Voting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional .types.VotingType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::types::VotingType type() const;
  void set_type(::types::VotingType value);

  // repeated .types.ITarget targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  const ::types::ITarget& targets(int index) const;
  ::types::ITarget* mutable_targets(int index);
  ::types::ITarget* add_targets();
  ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
      mutable_targets();
  const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
      targets() const;

  // map<string, int32> votes_for = 3;
  int votes_for_size() const;
  void clear_votes_for();
  static const int kVotesForFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
      votes_for() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
      mutable_votes_for();

  // @@protoc_insertion_point(class_scope:Xenophobia.Voting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::types::ITarget > targets_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 >
      Voting_VotesForEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > votes_for_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static Voting* default_instance_;
};
// -------------------------------------------------------------------

class EndVoting : public ::google::protobuf::Message {
 public:
  EndVoting();
  virtual ~EndVoting();

  EndVoting(const EndVoting& from);

  inline EndVoting& operator=(const EndVoting& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndVoting& default_instance();

  void Swap(EndVoting* other);

  // implements Message ----------------------------------------------

  inline EndVoting* New() const { return New(NULL); }

  EndVoting* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndVoting& from);
  void MergeFrom(const EndVoting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndVoting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.VotingType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::types::VotingType type() const;
  void set_type(::types::VotingType value);

  // optional .types.ITarget target = 2;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  const ::types::ITarget& target() const;
  ::types::ITarget* mutable_target();
  ::types::ITarget* release_target();
  void set_allocated_target(::types::ITarget* target);

  // optional string result = 3;
  void clear_result();
  static const int kResultFieldNumber = 3;
  const ::std::string& result() const;
  void set_result(const ::std::string& value);
  void set_result(const char* value);
  void set_result(const char* value, size_t size);
  ::std::string* mutable_result();
  ::std::string* release_result();
  void set_allocated_result(::std::string* result);

  // @@protoc_insertion_point(class_scope:Xenophobia.EndVoting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::types::ITarget* target_;
  ::google::protobuf::internal::ArenaStringPtr result_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static EndVoting* default_instance_;
};
// -------------------------------------------------------------------

class Change : public ::google::protobuf::Message {
 public:
  Change();
  virtual ~Change();

  Change(const Change& from);

  inline Change& operator=(const Change& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Change& default_instance();

  void Swap(Change* other);

  // implements Message ----------------------------------------------

  inline Change* New() const { return New(NULL); }

  Change* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Change& from);
  void MergeFrom(const Change& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Change* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.Event events = 1;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  const ::types::Event& events(int index) const;
  ::types::Event* mutable_events(int index);
  ::types::Event* add_events();
  ::google::protobuf::RepeatedPtrField< ::types::Event >*
      mutable_events();
  const ::google::protobuf::RepeatedPtrField< ::types::Event >&
      events() const;

  // @@protoc_insertion_point(class_scope:Xenophobia.Change)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::types::Event > events_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static Change* default_instance_;
};
// -------------------------------------------------------------------

class InvetoryChange : public ::google::protobuf::Message {
 public:
  InvetoryChange();
  virtual ~InvetoryChange();

  InvetoryChange(const InvetoryChange& from);

  inline InvetoryChange& operator=(const InvetoryChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvetoryChange& default_instance();

  void Swap(InvetoryChange* other);

  // implements Message ----------------------------------------------

  inline InvetoryChange* New() const { return New(NULL); }

  InvetoryChange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvetoryChange& from);
  void MergeFrom(const InvetoryChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvetoryChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InvetoryChange_ChangeType ChangeType;
  static const ChangeType ADD_ITEM = InvetoryChange_ChangeType_ADD_ITEM;
  static const ChangeType CHARGE_ITEM = InvetoryChange_ChangeType_CHARGE_ITEM;
  static const ChangeType DEL_ITEM = InvetoryChange_ChangeType_DEL_ITEM;
  static inline bool ChangeType_IsValid(int value) {
    return InvetoryChange_ChangeType_IsValid(value);
  }
  static const ChangeType ChangeType_MIN =
    InvetoryChange_ChangeType_ChangeType_MIN;
  static const ChangeType ChangeType_MAX =
    InvetoryChange_ChangeType_ChangeType_MAX;
  static const int ChangeType_ARRAYSIZE =
    InvetoryChange_ChangeType_ChangeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ChangeType_descriptor() {
    return InvetoryChange_ChangeType_descriptor();
  }
  static inline const ::std::string& ChangeType_Name(ChangeType value) {
    return InvetoryChange_ChangeType_Name(value);
  }
  static inline bool ChangeType_Parse(const ::std::string& name,
      ChangeType* value) {
    return InvetoryChange_ChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Xenophobia.InvetoryChange.ChangeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::InvetoryChange_ChangeType type() const;
  void set_type(::Xenophobia::InvetoryChange_ChangeType value);

  // optional .types.Item item = 2;
  void clear_item();
  static const int kItemFieldNumber = 2;
  ::types::Item item() const;
  void set_item(::types::Item value);

  // optional int32 charge = 3;
  void clear_charge();
  static const int kChargeFieldNumber = 3;
  ::google::protobuf::int32 charge() const;
  void set_charge(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.InvetoryChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  int item_;
  ::google::protobuf::int32 charge_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static InvetoryChange* default_instance_;
};
// -------------------------------------------------------------------

class PlayerChange : public ::google::protobuf::Message {
 public:
  PlayerChange();
  virtual ~PlayerChange();

  PlayerChange(const PlayerChange& from);

  inline PlayerChange& operator=(const PlayerChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerChange& default_instance();

  void Swap(PlayerChange* other);

  // implements Message ----------------------------------------------

  inline PlayerChange* New() const { return New(NULL); }

  PlayerChange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerChange& from);
  void MergeFrom(const PlayerChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerChange_ChangeType ChangeType;
  static const ChangeType HP_CHANGE = PlayerChange_ChangeType_HP_CHANGE;
  static const ChangeType ALIEN = PlayerChange_ChangeType_ALIEN;
  static const ChangeType STATUS_CHANGE = PlayerChange_ChangeType_STATUS_CHANGE;
  static inline bool ChangeType_IsValid(int value) {
    return PlayerChange_ChangeType_IsValid(value);
  }
  static const ChangeType ChangeType_MIN =
    PlayerChange_ChangeType_ChangeType_MIN;
  static const ChangeType ChangeType_MAX =
    PlayerChange_ChangeType_ChangeType_MAX;
  static const int ChangeType_ARRAYSIZE =
    PlayerChange_ChangeType_ChangeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ChangeType_descriptor() {
    return PlayerChange_ChangeType_descriptor();
  }
  static inline const ::std::string& ChangeType_Name(ChangeType value) {
    return PlayerChange_ChangeType_Name(value);
  }
  static inline bool ChangeType_Parse(const ::std::string& name,
      ChangeType* value) {
    return PlayerChange_ChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Xenophobia.PlayerChange.ChangeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::PlayerChange_ChangeType type() const;
  void set_type(::Xenophobia::PlayerChange_ChangeType value);

  // optional int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Xenophobia.PlayerChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::int32 value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static PlayerChange* default_instance_;
};
// -------------------------------------------------------------------

class ActionRequest : public ::google::protobuf::Message {
 public:
  ActionRequest();
  virtual ~ActionRequest();

  ActionRequest(const ActionRequest& from);

  inline ActionRequest& operator=(const ActionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRequest& default_instance();

  void Swap(ActionRequest* other);

  // implements Message ----------------------------------------------

  inline ActionRequest* New() const { return New(NULL); }

  ActionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRequest& from);
  void MergeFrom(const ActionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActionRequest_RequestType RequestType;
  static const RequestType HARD_RESOLVE = ActionRequest_RequestType_HARD_RESOLVE;
  static const RequestType NEED_ROTATION = ActionRequest_RequestType_NEED_ROTATION;
  static inline bool RequestType_IsValid(int value) {
    return ActionRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    ActionRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    ActionRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    ActionRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return ActionRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return ActionRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return ActionRequest_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Xenophobia.ActionRequest.RequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::ActionRequest_RequestType type() const;
  void set_type(::Xenophobia::ActionRequest_RequestType value);

  // repeated .types.ITarget targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  const ::types::ITarget& targets(int index) const;
  ::types::ITarget* mutable_targets(int index);
  ::types::ITarget* add_targets();
  ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
      mutable_targets();
  const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:Xenophobia.ActionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::types::ITarget > targets_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static ActionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ActionResult : public ::google::protobuf::Message {
 public:
  ActionResult();
  virtual ~ActionResult();

  ActionResult(const ActionResult& from);

  inline ActionResult& operator=(const ActionResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionResult& default_instance();

  void Swap(ActionResult* other);

  // implements Message ----------------------------------------------

  inline ActionResult* New() const { return New(NULL); }

  ActionResult* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionResult& from);
  void MergeFrom(const ActionResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActionResult_ResultType ResultType;
  static const ResultType USED_ITEM = ActionResult_ResultType_USED_ITEM;
  static const ResultType USE_ACTION = ActionResult_ResultType_USE_ACTION;
  static inline bool ResultType_IsValid(int value) {
    return ActionResult_ResultType_IsValid(value);
  }
  static const ResultType ResultType_MIN =
    ActionResult_ResultType_ResultType_MIN;
  static const ResultType ResultType_MAX =
    ActionResult_ResultType_ResultType_MAX;
  static const int ResultType_ARRAYSIZE =
    ActionResult_ResultType_ResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultType_descriptor() {
    return ActionResult_ResultType_descriptor();
  }
  static inline const ::std::string& ResultType_Name(ResultType value) {
    return ActionResult_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(const ::std::string& name,
      ResultType* value) {
    return ActionResult_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Xenophobia.ActionResult.ResultType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::ActionResult_ResultType type() const;
  void set_type(::Xenophobia::ActionResult_ResultType value);

  // optional .types.Action action = 2;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::types::Action action() const;
  void set_action(::types::Action value);

  // @@protoc_insertion_point(class_scope:Xenophobia.ActionResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  int action_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static ActionResult* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  void Swap(ServerMessage* other);

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const { return New(NULL); }

  ServerMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Xenophobia.ServerMessageType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Xenophobia::ServerMessageType type() const;
  void set_type(::Xenophobia::ServerMessageType value);

  // optional .Xenophobia.RegisterAnswer register_answer = 2;
  bool has_register_answer() const;
  void clear_register_answer();
  static const int kRegisterAnswerFieldNumber = 2;
  const ::Xenophobia::RegisterAnswer& register_answer() const;
  ::Xenophobia::RegisterAnswer* mutable_register_answer();
  ::Xenophobia::RegisterAnswer* release_register_answer();
  void set_allocated_register_answer(::Xenophobia::RegisterAnswer* register_answer);

  // optional .Xenophobia.RegisterUpdate register_update = 3;
  bool has_register_update() const;
  void clear_register_update();
  static const int kRegisterUpdateFieldNumber = 3;
  const ::Xenophobia::RegisterUpdate& register_update() const;
  ::Xenophobia::RegisterUpdate* mutable_register_update();
  ::Xenophobia::RegisterUpdate* release_register_update();
  void set_allocated_register_update(::Xenophobia::RegisterUpdate* register_update);

  // optional .Xenophobia.StartGame start_game = 4;
  bool has_start_game() const;
  void clear_start_game();
  static const int kStartGameFieldNumber = 4;
  const ::Xenophobia::StartGame& start_game() const;
  ::Xenophobia::StartGame* mutable_start_game();
  ::Xenophobia::StartGame* release_start_game();
  void set_allocated_start_game(::Xenophobia::StartGame* start_game);

  // optional .Xenophobia.TimeSwitch time_switch = 5;
  bool has_time_switch() const;
  void clear_time_switch();
  static const int kTimeSwitchFieldNumber = 5;
  const ::Xenophobia::TimeSwitch& time_switch() const;
  ::Xenophobia::TimeSwitch* mutable_time_switch();
  ::Xenophobia::TimeSwitch* release_time_switch();
  void set_allocated_time_switch(::Xenophobia::TimeSwitch* time_switch);

  // optional .Xenophobia.Voting voting = 6;
  bool has_voting() const;
  void clear_voting();
  static const int kVotingFieldNumber = 6;
  const ::Xenophobia::Voting& voting() const;
  ::Xenophobia::Voting* mutable_voting();
  ::Xenophobia::Voting* release_voting();
  void set_allocated_voting(::Xenophobia::Voting* voting);

  // optional .Xenophobia.EndVoting end_voting = 7;
  bool has_end_voting() const;
  void clear_end_voting();
  static const int kEndVotingFieldNumber = 7;
  const ::Xenophobia::EndVoting& end_voting() const;
  ::Xenophobia::EndVoting* mutable_end_voting();
  ::Xenophobia::EndVoting* release_end_voting();
  void set_allocated_end_voting(::Xenophobia::EndVoting* end_voting);

  // optional .Xenophobia.Change change = 8;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 8;
  const ::Xenophobia::Change& change() const;
  ::Xenophobia::Change* mutable_change();
  ::Xenophobia::Change* release_change();
  void set_allocated_change(::Xenophobia::Change* change);

  // optional .Xenophobia.InvetoryChange inventory_change = 9;
  bool has_inventory_change() const;
  void clear_inventory_change();
  static const int kInventoryChangeFieldNumber = 9;
  const ::Xenophobia::InvetoryChange& inventory_change() const;
  ::Xenophobia::InvetoryChange* mutable_inventory_change();
  ::Xenophobia::InvetoryChange* release_inventory_change();
  void set_allocated_inventory_change(::Xenophobia::InvetoryChange* inventory_change);

  // optional .Xenophobia.PlayerChange player_change = 10;
  bool has_player_change() const;
  void clear_player_change();
  static const int kPlayerChangeFieldNumber = 10;
  const ::Xenophobia::PlayerChange& player_change() const;
  ::Xenophobia::PlayerChange* mutable_player_change();
  ::Xenophobia::PlayerChange* release_player_change();
  void set_allocated_player_change(::Xenophobia::PlayerChange* player_change);

  // optional .Xenophobia.ActionRequest action_request = 11;
  bool has_action_request() const;
  void clear_action_request();
  static const int kActionRequestFieldNumber = 11;
  const ::Xenophobia::ActionRequest& action_request() const;
  ::Xenophobia::ActionRequest* mutable_action_request();
  ::Xenophobia::ActionRequest* release_action_request();
  void set_allocated_action_request(::Xenophobia::ActionRequest* action_request);

  // optional .Xenophobia.ActionResult action_result = 12;
  bool has_action_result() const;
  void clear_action_result();
  static const int kActionResultFieldNumber = 12;
  const ::Xenophobia::ActionResult& action_result() const;
  ::Xenophobia::ActionResult* mutable_action_result();
  ::Xenophobia::ActionResult* release_action_result();
  void set_allocated_action_result(::Xenophobia::ActionResult* action_result);

  // @@protoc_insertion_point(class_scope:Xenophobia.ServerMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Xenophobia::RegisterAnswer* register_answer_;
  ::Xenophobia::RegisterUpdate* register_update_;
  ::Xenophobia::StartGame* start_game_;
  ::Xenophobia::TimeSwitch* time_switch_;
  ::Xenophobia::Voting* voting_;
  ::Xenophobia::EndVoting* end_voting_;
  ::Xenophobia::Change* change_;
  ::Xenophobia::InvetoryChange* inventory_change_;
  ::Xenophobia::PlayerChange* player_change_;
  ::Xenophobia::ActionRequest* action_request_;
  ::Xenophobia::ActionResult* action_result_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_server_2eproto();
  friend void protobuf_AssignDesc_server_2eproto();
  friend void protobuf_ShutdownFile_server_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterAnswer

// optional .Xenophobia.RegisterAnswer.StatusType status = 1;
inline void RegisterAnswer::clear_status() {
  status_ = 0;
}
inline ::Xenophobia::RegisterAnswer_StatusType RegisterAnswer::status() const {
  // @@protoc_insertion_point(field_get:Xenophobia.RegisterAnswer.status)
  return static_cast< ::Xenophobia::RegisterAnswer_StatusType >(status_);
}
inline void RegisterAnswer::set_status(::Xenophobia::RegisterAnswer_StatusType value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.RegisterAnswer.status)
}

// -------------------------------------------------------------------

// RegisterUpdate

// map<string, .types.Role> players = 1;
inline int RegisterUpdate::players_size() const {
  return players_.size();
}
inline void RegisterUpdate::clear_players() {
  players_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::types::Role >&
RegisterUpdate::players() const {
  // @@protoc_insertion_point(field_map:Xenophobia.RegisterUpdate.players)
  return players_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::types::Role >*
RegisterUpdate::mutable_players() {
  // @@protoc_insertion_point(field_mutable_map:Xenophobia.RegisterUpdate.players)
  return players_.MutableMap();
}

// -------------------------------------------------------------------

// StartGame_PlayerInfo

// optional .types.PlayerStatus status = 1;
inline void StartGame_PlayerInfo::clear_status() {
  status_ = 0;
}
inline ::types::PlayerStatus StartGame_PlayerInfo::status() const {
  // @@protoc_insertion_point(field_get:Xenophobia.StartGame.PlayerInfo.status)
  return static_cast< ::types::PlayerStatus >(status_);
}
inline void StartGame_PlayerInfo::set_status(::types::PlayerStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.StartGame.PlayerInfo.status)
}

// optional bool online = 2;
inline void StartGame_PlayerInfo::clear_online() {
  online_ = false;
}
inline bool StartGame_PlayerInfo::online() const {
  // @@protoc_insertion_point(field_get:Xenophobia.StartGame.PlayerInfo.online)
  return online_;
}
inline void StartGame_PlayerInfo::set_online(bool value) {
  
  online_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.StartGame.PlayerInfo.online)
}

// optional bool onduty = 3;
inline void StartGame_PlayerInfo::clear_onduty() {
  onduty_ = false;
}
inline bool StartGame_PlayerInfo::onduty() const {
  // @@protoc_insertion_point(field_get:Xenophobia.StartGame.PlayerInfo.onduty)
  return onduty_;
}
inline void StartGame_PlayerInfo::set_onduty(bool value) {
  
  onduty_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.StartGame.PlayerInfo.onduty)
}

// optional int32 avatar = 4;
inline void StartGame_PlayerInfo::clear_avatar() {
  avatar_ = 0;
}
inline ::google::protobuf::int32 StartGame_PlayerInfo::avatar() const {
  // @@protoc_insertion_point(field_get:Xenophobia.StartGame.PlayerInfo.avatar)
  return avatar_;
}
inline void StartGame_PlayerInfo::set_avatar(::google::protobuf::int32 value) {
  
  avatar_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.StartGame.PlayerInfo.avatar)
}

// -------------------------------------------------------------------

// StartGame

// repeated .Xenophobia.StartGame.PlayerInfo players = 1;
inline int StartGame::players_size() const {
  return players_.size();
}
inline void StartGame::clear_players() {
  players_.Clear();
}
inline const ::Xenophobia::StartGame_PlayerInfo& StartGame::players(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.StartGame.players)
  return players_.Get(index);
}
inline ::Xenophobia::StartGame_PlayerInfo* StartGame::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.StartGame.players)
  return players_.Mutable(index);
}
inline ::Xenophobia::StartGame_PlayerInfo* StartGame::add_players() {
  // @@protoc_insertion_point(field_add:Xenophobia.StartGame.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Xenophobia::StartGame_PlayerInfo >*
StartGame::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.StartGame.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Xenophobia::StartGame_PlayerInfo >&
StartGame::players() const {
  // @@protoc_insertion_point(field_list:Xenophobia.StartGame.players)
  return players_;
}

// -------------------------------------------------------------------

// TimeSwitch

// optional .Xenophobia.TimeSwitch.TimeType time = 1;
inline void TimeSwitch::clear_time() {
  time_ = 0;
}
inline ::Xenophobia::TimeSwitch_TimeType TimeSwitch::time() const {
  // @@protoc_insertion_point(field_get:Xenophobia.TimeSwitch.time)
  return static_cast< ::Xenophobia::TimeSwitch_TimeType >(time_);
}
inline void TimeSwitch::set_time(::Xenophobia::TimeSwitch_TimeType value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.TimeSwitch.time)
}

// optional int32 day_number = 2;
inline void TimeSwitch::clear_day_number() {
  day_number_ = 0;
}
inline ::google::protobuf::int32 TimeSwitch::day_number() const {
  // @@protoc_insertion_point(field_get:Xenophobia.TimeSwitch.day_number)
  return day_number_;
}
inline void TimeSwitch::set_day_number(::google::protobuf::int32 value) {
  
  day_number_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.TimeSwitch.day_number)
}

// -------------------------------------------------------------------

// Voting

// optional .types.VotingType type = 1;
inline void Voting::clear_type() {
  type_ = 0;
}
inline ::types::VotingType Voting::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.Voting.type)
  return static_cast< ::types::VotingType >(type_);
}
inline void Voting::set_type(::types::VotingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.Voting.type)
}

// repeated .types.ITarget targets = 2;
inline int Voting::targets_size() const {
  return targets_.size();
}
inline void Voting::clear_targets() {
  targets_.Clear();
}
inline const ::types::ITarget& Voting::targets(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.Voting.targets)
  return targets_.Get(index);
}
inline ::types::ITarget* Voting::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.Voting.targets)
  return targets_.Mutable(index);
}
inline ::types::ITarget* Voting::add_targets() {
  // @@protoc_insertion_point(field_add:Xenophobia.Voting.targets)
  return targets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
Voting::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.Voting.targets)
  return &targets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
Voting::targets() const {
  // @@protoc_insertion_point(field_list:Xenophobia.Voting.targets)
  return targets_;
}

// map<string, int32> votes_for = 3;
inline int Voting::votes_for_size() const {
  return votes_for_.size();
}
inline void Voting::clear_votes_for() {
  votes_for_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
Voting::votes_for() const {
  // @@protoc_insertion_point(field_map:Xenophobia.Voting.votes_for)
  return votes_for_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
Voting::mutable_votes_for() {
  // @@protoc_insertion_point(field_mutable_map:Xenophobia.Voting.votes_for)
  return votes_for_.MutableMap();
}

// -------------------------------------------------------------------

// EndVoting

// optional .types.VotingType type = 1;
inline void EndVoting::clear_type() {
  type_ = 0;
}
inline ::types::VotingType EndVoting::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.EndVoting.type)
  return static_cast< ::types::VotingType >(type_);
}
inline void EndVoting::set_type(::types::VotingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.EndVoting.type)
}

// optional .types.ITarget target = 2;
inline bool EndVoting::has_target() const {
  return !_is_default_instance_ && target_ != NULL;
}
inline void EndVoting::clear_target() {
  if (GetArenaNoVirtual() == NULL && target_ != NULL) delete target_;
  target_ = NULL;
}
inline const ::types::ITarget& EndVoting::target() const {
  // @@protoc_insertion_point(field_get:Xenophobia.EndVoting.target)
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::types::ITarget* EndVoting::mutable_target() {
  
  if (target_ == NULL) {
    target_ = new ::types::ITarget;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.EndVoting.target)
  return target_;
}
inline ::types::ITarget* EndVoting::release_target() {
  
  ::types::ITarget* temp = target_;
  target_ = NULL;
  return temp;
}
inline void EndVoting::set_allocated_target(::types::ITarget* target) {
  delete target_;
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.EndVoting.target)
}

// optional string result = 3;
inline void EndVoting::clear_result() {
  result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EndVoting::result() const {
  // @@protoc_insertion_point(field_get:Xenophobia.EndVoting.result)
  return result_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndVoting::set_result(const ::std::string& value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Xenophobia.EndVoting.result)
}
inline void EndVoting::set_result(const char* value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Xenophobia.EndVoting.result)
}
inline void EndVoting::set_result(const char* value, size_t size) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Xenophobia.EndVoting.result)
}
inline ::std::string* EndVoting::mutable_result() {
  
  // @@protoc_insertion_point(field_mutable:Xenophobia.EndVoting.result)
  return result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EndVoting::release_result() {
  
  return result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndVoting::set_allocated_result(::std::string* result) {
  if (result != NULL) {
    
  } else {
    
  }
  result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.EndVoting.result)
}

// -------------------------------------------------------------------

// Change

// repeated .types.Event events = 1;
inline int Change::events_size() const {
  return events_.size();
}
inline void Change::clear_events() {
  events_.Clear();
}
inline const ::types::Event& Change::events(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.Change.events)
  return events_.Get(index);
}
inline ::types::Event* Change::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.Change.events)
  return events_.Mutable(index);
}
inline ::types::Event* Change::add_events() {
  // @@protoc_insertion_point(field_add:Xenophobia.Change.events)
  return events_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::Event >*
Change::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.Change.events)
  return &events_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Event >&
Change::events() const {
  // @@protoc_insertion_point(field_list:Xenophobia.Change.events)
  return events_;
}

// -------------------------------------------------------------------

// InvetoryChange

// optional .Xenophobia.InvetoryChange.ChangeType type = 1;
inline void InvetoryChange::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::InvetoryChange_ChangeType InvetoryChange::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.InvetoryChange.type)
  return static_cast< ::Xenophobia::InvetoryChange_ChangeType >(type_);
}
inline void InvetoryChange::set_type(::Xenophobia::InvetoryChange_ChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.InvetoryChange.type)
}

// optional .types.Item item = 2;
inline void InvetoryChange::clear_item() {
  item_ = 0;
}
inline ::types::Item InvetoryChange::item() const {
  // @@protoc_insertion_point(field_get:Xenophobia.InvetoryChange.item)
  return static_cast< ::types::Item >(item_);
}
inline void InvetoryChange::set_item(::types::Item value) {
  
  item_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.InvetoryChange.item)
}

// optional int32 charge = 3;
inline void InvetoryChange::clear_charge() {
  charge_ = 0;
}
inline ::google::protobuf::int32 InvetoryChange::charge() const {
  // @@protoc_insertion_point(field_get:Xenophobia.InvetoryChange.charge)
  return charge_;
}
inline void InvetoryChange::set_charge(::google::protobuf::int32 value) {
  
  charge_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.InvetoryChange.charge)
}

// -------------------------------------------------------------------

// PlayerChange

// optional .Xenophobia.PlayerChange.ChangeType type = 1;
inline void PlayerChange::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::PlayerChange_ChangeType PlayerChange::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerChange.type)
  return static_cast< ::Xenophobia::PlayerChange_ChangeType >(type_);
}
inline void PlayerChange::set_type(::Xenophobia::PlayerChange_ChangeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerChange.type)
}

// optional int32 value = 2;
inline void PlayerChange::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 PlayerChange::value() const {
  // @@protoc_insertion_point(field_get:Xenophobia.PlayerChange.value)
  return value_;
}
inline void PlayerChange::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.PlayerChange.value)
}

// -------------------------------------------------------------------

// ActionRequest

// optional .Xenophobia.ActionRequest.RequestType type = 1;
inline void ActionRequest::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::ActionRequest_RequestType ActionRequest::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionRequest.type)
  return static_cast< ::Xenophobia::ActionRequest_RequestType >(type_);
}
inline void ActionRequest::set_type(::Xenophobia::ActionRequest_RequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ActionRequest.type)
}

// repeated .types.ITarget targets = 2;
inline int ActionRequest::targets_size() const {
  return targets_.size();
}
inline void ActionRequest::clear_targets() {
  targets_.Clear();
}
inline const ::types::ITarget& ActionRequest::targets(int index) const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionRequest.targets)
  return targets_.Get(index);
}
inline ::types::ITarget* ActionRequest::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:Xenophobia.ActionRequest.targets)
  return targets_.Mutable(index);
}
inline ::types::ITarget* ActionRequest::add_targets() {
  // @@protoc_insertion_point(field_add:Xenophobia.ActionRequest.targets)
  return targets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ITarget >*
ActionRequest::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:Xenophobia.ActionRequest.targets)
  return &targets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ITarget >&
ActionRequest::targets() const {
  // @@protoc_insertion_point(field_list:Xenophobia.ActionRequest.targets)
  return targets_;
}

// -------------------------------------------------------------------

// ActionResult

// optional .Xenophobia.ActionResult.ResultType type = 1;
inline void ActionResult::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::ActionResult_ResultType ActionResult::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionResult.type)
  return static_cast< ::Xenophobia::ActionResult_ResultType >(type_);
}
inline void ActionResult::set_type(::Xenophobia::ActionResult_ResultType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ActionResult.type)
}

// optional .types.Action action = 2;
inline void ActionResult::clear_action() {
  action_ = 0;
}
inline ::types::Action ActionResult::action() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ActionResult.action)
  return static_cast< ::types::Action >(action_);
}
inline void ActionResult::set_action(::types::Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ActionResult.action)
}

// -------------------------------------------------------------------

// ServerMessage

// optional .Xenophobia.ServerMessageType type = 1;
inline void ServerMessage::clear_type() {
  type_ = 0;
}
inline ::Xenophobia::ServerMessageType ServerMessage::type() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.type)
  return static_cast< ::Xenophobia::ServerMessageType >(type_);
}
inline void ServerMessage::set_type(::Xenophobia::ServerMessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Xenophobia.ServerMessage.type)
}

// optional .Xenophobia.RegisterAnswer register_answer = 2;
inline bool ServerMessage::has_register_answer() const {
  return !_is_default_instance_ && register_answer_ != NULL;
}
inline void ServerMessage::clear_register_answer() {
  if (GetArenaNoVirtual() == NULL && register_answer_ != NULL) delete register_answer_;
  register_answer_ = NULL;
}
inline const ::Xenophobia::RegisterAnswer& ServerMessage::register_answer() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.register_answer)
  return register_answer_ != NULL ? *register_answer_ : *default_instance_->register_answer_;
}
inline ::Xenophobia::RegisterAnswer* ServerMessage::mutable_register_answer() {
  
  if (register_answer_ == NULL) {
    register_answer_ = new ::Xenophobia::RegisterAnswer;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.register_answer)
  return register_answer_;
}
inline ::Xenophobia::RegisterAnswer* ServerMessage::release_register_answer() {
  
  ::Xenophobia::RegisterAnswer* temp = register_answer_;
  register_answer_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_register_answer(::Xenophobia::RegisterAnswer* register_answer) {
  delete register_answer_;
  register_answer_ = register_answer;
  if (register_answer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.register_answer)
}

// optional .Xenophobia.RegisterUpdate register_update = 3;
inline bool ServerMessage::has_register_update() const {
  return !_is_default_instance_ && register_update_ != NULL;
}
inline void ServerMessage::clear_register_update() {
  if (GetArenaNoVirtual() == NULL && register_update_ != NULL) delete register_update_;
  register_update_ = NULL;
}
inline const ::Xenophobia::RegisterUpdate& ServerMessage::register_update() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.register_update)
  return register_update_ != NULL ? *register_update_ : *default_instance_->register_update_;
}
inline ::Xenophobia::RegisterUpdate* ServerMessage::mutable_register_update() {
  
  if (register_update_ == NULL) {
    register_update_ = new ::Xenophobia::RegisterUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.register_update)
  return register_update_;
}
inline ::Xenophobia::RegisterUpdate* ServerMessage::release_register_update() {
  
  ::Xenophobia::RegisterUpdate* temp = register_update_;
  register_update_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_register_update(::Xenophobia::RegisterUpdate* register_update) {
  delete register_update_;
  register_update_ = register_update;
  if (register_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.register_update)
}

// optional .Xenophobia.StartGame start_game = 4;
inline bool ServerMessage::has_start_game() const {
  return !_is_default_instance_ && start_game_ != NULL;
}
inline void ServerMessage::clear_start_game() {
  if (GetArenaNoVirtual() == NULL && start_game_ != NULL) delete start_game_;
  start_game_ = NULL;
}
inline const ::Xenophobia::StartGame& ServerMessage::start_game() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.start_game)
  return start_game_ != NULL ? *start_game_ : *default_instance_->start_game_;
}
inline ::Xenophobia::StartGame* ServerMessage::mutable_start_game() {
  
  if (start_game_ == NULL) {
    start_game_ = new ::Xenophobia::StartGame;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.start_game)
  return start_game_;
}
inline ::Xenophobia::StartGame* ServerMessage::release_start_game() {
  
  ::Xenophobia::StartGame* temp = start_game_;
  start_game_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_start_game(::Xenophobia::StartGame* start_game) {
  delete start_game_;
  start_game_ = start_game;
  if (start_game) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.start_game)
}

// optional .Xenophobia.TimeSwitch time_switch = 5;
inline bool ServerMessage::has_time_switch() const {
  return !_is_default_instance_ && time_switch_ != NULL;
}
inline void ServerMessage::clear_time_switch() {
  if (GetArenaNoVirtual() == NULL && time_switch_ != NULL) delete time_switch_;
  time_switch_ = NULL;
}
inline const ::Xenophobia::TimeSwitch& ServerMessage::time_switch() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.time_switch)
  return time_switch_ != NULL ? *time_switch_ : *default_instance_->time_switch_;
}
inline ::Xenophobia::TimeSwitch* ServerMessage::mutable_time_switch() {
  
  if (time_switch_ == NULL) {
    time_switch_ = new ::Xenophobia::TimeSwitch;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.time_switch)
  return time_switch_;
}
inline ::Xenophobia::TimeSwitch* ServerMessage::release_time_switch() {
  
  ::Xenophobia::TimeSwitch* temp = time_switch_;
  time_switch_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_time_switch(::Xenophobia::TimeSwitch* time_switch) {
  delete time_switch_;
  time_switch_ = time_switch;
  if (time_switch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.time_switch)
}

// optional .Xenophobia.Voting voting = 6;
inline bool ServerMessage::has_voting() const {
  return !_is_default_instance_ && voting_ != NULL;
}
inline void ServerMessage::clear_voting() {
  if (GetArenaNoVirtual() == NULL && voting_ != NULL) delete voting_;
  voting_ = NULL;
}
inline const ::Xenophobia::Voting& ServerMessage::voting() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.voting)
  return voting_ != NULL ? *voting_ : *default_instance_->voting_;
}
inline ::Xenophobia::Voting* ServerMessage::mutable_voting() {
  
  if (voting_ == NULL) {
    voting_ = new ::Xenophobia::Voting;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.voting)
  return voting_;
}
inline ::Xenophobia::Voting* ServerMessage::release_voting() {
  
  ::Xenophobia::Voting* temp = voting_;
  voting_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_voting(::Xenophobia::Voting* voting) {
  delete voting_;
  voting_ = voting;
  if (voting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.voting)
}

// optional .Xenophobia.EndVoting end_voting = 7;
inline bool ServerMessage::has_end_voting() const {
  return !_is_default_instance_ && end_voting_ != NULL;
}
inline void ServerMessage::clear_end_voting() {
  if (GetArenaNoVirtual() == NULL && end_voting_ != NULL) delete end_voting_;
  end_voting_ = NULL;
}
inline const ::Xenophobia::EndVoting& ServerMessage::end_voting() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.end_voting)
  return end_voting_ != NULL ? *end_voting_ : *default_instance_->end_voting_;
}
inline ::Xenophobia::EndVoting* ServerMessage::mutable_end_voting() {
  
  if (end_voting_ == NULL) {
    end_voting_ = new ::Xenophobia::EndVoting;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.end_voting)
  return end_voting_;
}
inline ::Xenophobia::EndVoting* ServerMessage::release_end_voting() {
  
  ::Xenophobia::EndVoting* temp = end_voting_;
  end_voting_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_end_voting(::Xenophobia::EndVoting* end_voting) {
  delete end_voting_;
  end_voting_ = end_voting;
  if (end_voting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.end_voting)
}

// optional .Xenophobia.Change change = 8;
inline bool ServerMessage::has_change() const {
  return !_is_default_instance_ && change_ != NULL;
}
inline void ServerMessage::clear_change() {
  if (GetArenaNoVirtual() == NULL && change_ != NULL) delete change_;
  change_ = NULL;
}
inline const ::Xenophobia::Change& ServerMessage::change() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.change)
  return change_ != NULL ? *change_ : *default_instance_->change_;
}
inline ::Xenophobia::Change* ServerMessage::mutable_change() {
  
  if (change_ == NULL) {
    change_ = new ::Xenophobia::Change;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.change)
  return change_;
}
inline ::Xenophobia::Change* ServerMessage::release_change() {
  
  ::Xenophobia::Change* temp = change_;
  change_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_change(::Xenophobia::Change* change) {
  delete change_;
  change_ = change;
  if (change) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.change)
}

// optional .Xenophobia.InvetoryChange inventory_change = 9;
inline bool ServerMessage::has_inventory_change() const {
  return !_is_default_instance_ && inventory_change_ != NULL;
}
inline void ServerMessage::clear_inventory_change() {
  if (GetArenaNoVirtual() == NULL && inventory_change_ != NULL) delete inventory_change_;
  inventory_change_ = NULL;
}
inline const ::Xenophobia::InvetoryChange& ServerMessage::inventory_change() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.inventory_change)
  return inventory_change_ != NULL ? *inventory_change_ : *default_instance_->inventory_change_;
}
inline ::Xenophobia::InvetoryChange* ServerMessage::mutable_inventory_change() {
  
  if (inventory_change_ == NULL) {
    inventory_change_ = new ::Xenophobia::InvetoryChange;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.inventory_change)
  return inventory_change_;
}
inline ::Xenophobia::InvetoryChange* ServerMessage::release_inventory_change() {
  
  ::Xenophobia::InvetoryChange* temp = inventory_change_;
  inventory_change_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_inventory_change(::Xenophobia::InvetoryChange* inventory_change) {
  delete inventory_change_;
  inventory_change_ = inventory_change;
  if (inventory_change) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.inventory_change)
}

// optional .Xenophobia.PlayerChange player_change = 10;
inline bool ServerMessage::has_player_change() const {
  return !_is_default_instance_ && player_change_ != NULL;
}
inline void ServerMessage::clear_player_change() {
  if (GetArenaNoVirtual() == NULL && player_change_ != NULL) delete player_change_;
  player_change_ = NULL;
}
inline const ::Xenophobia::PlayerChange& ServerMessage::player_change() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.player_change)
  return player_change_ != NULL ? *player_change_ : *default_instance_->player_change_;
}
inline ::Xenophobia::PlayerChange* ServerMessage::mutable_player_change() {
  
  if (player_change_ == NULL) {
    player_change_ = new ::Xenophobia::PlayerChange;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.player_change)
  return player_change_;
}
inline ::Xenophobia::PlayerChange* ServerMessage::release_player_change() {
  
  ::Xenophobia::PlayerChange* temp = player_change_;
  player_change_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_player_change(::Xenophobia::PlayerChange* player_change) {
  delete player_change_;
  player_change_ = player_change;
  if (player_change) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.player_change)
}

// optional .Xenophobia.ActionRequest action_request = 11;
inline bool ServerMessage::has_action_request() const {
  return !_is_default_instance_ && action_request_ != NULL;
}
inline void ServerMessage::clear_action_request() {
  if (GetArenaNoVirtual() == NULL && action_request_ != NULL) delete action_request_;
  action_request_ = NULL;
}
inline const ::Xenophobia::ActionRequest& ServerMessage::action_request() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.action_request)
  return action_request_ != NULL ? *action_request_ : *default_instance_->action_request_;
}
inline ::Xenophobia::ActionRequest* ServerMessage::mutable_action_request() {
  
  if (action_request_ == NULL) {
    action_request_ = new ::Xenophobia::ActionRequest;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.action_request)
  return action_request_;
}
inline ::Xenophobia::ActionRequest* ServerMessage::release_action_request() {
  
  ::Xenophobia::ActionRequest* temp = action_request_;
  action_request_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_action_request(::Xenophobia::ActionRequest* action_request) {
  delete action_request_;
  action_request_ = action_request;
  if (action_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.action_request)
}

// optional .Xenophobia.ActionResult action_result = 12;
inline bool ServerMessage::has_action_result() const {
  return !_is_default_instance_ && action_result_ != NULL;
}
inline void ServerMessage::clear_action_result() {
  if (GetArenaNoVirtual() == NULL && action_result_ != NULL) delete action_result_;
  action_result_ = NULL;
}
inline const ::Xenophobia::ActionResult& ServerMessage::action_result() const {
  // @@protoc_insertion_point(field_get:Xenophobia.ServerMessage.action_result)
  return action_result_ != NULL ? *action_result_ : *default_instance_->action_result_;
}
inline ::Xenophobia::ActionResult* ServerMessage::mutable_action_result() {
  
  if (action_result_ == NULL) {
    action_result_ = new ::Xenophobia::ActionResult;
  }
  // @@protoc_insertion_point(field_mutable:Xenophobia.ServerMessage.action_result)
  return action_result_;
}
inline ::Xenophobia::ActionResult* ServerMessage::release_action_result() {
  
  ::Xenophobia::ActionResult* temp = action_result_;
  action_result_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_action_result(::Xenophobia::ActionResult* action_result) {
  delete action_result_;
  action_result_ = action_result;
  if (action_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Xenophobia.ServerMessage.action_result)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Xenophobia

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Xenophobia::RegisterAnswer_StatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::RegisterAnswer_StatusType>() {
  return ::Xenophobia::RegisterAnswer_StatusType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::TimeSwitch_TimeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::TimeSwitch_TimeType>() {
  return ::Xenophobia::TimeSwitch_TimeType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::InvetoryChange_ChangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::InvetoryChange_ChangeType>() {
  return ::Xenophobia::InvetoryChange_ChangeType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::PlayerChange_ChangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::PlayerChange_ChangeType>() {
  return ::Xenophobia::PlayerChange_ChangeType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::ActionRequest_RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::ActionRequest_RequestType>() {
  return ::Xenophobia::ActionRequest_RequestType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::ActionResult_ResultType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::ActionResult_ResultType>() {
  return ::Xenophobia::ActionResult_ResultType_descriptor();
}
template <> struct is_proto_enum< ::Xenophobia::ServerMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Xenophobia::ServerMessageType>() {
  return ::Xenophobia::ServerMessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_server_2eproto__INCLUDED
